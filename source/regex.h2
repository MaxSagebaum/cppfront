
//  Copyright (c) Herb Sutter
//  SPDX-License-Identifier: CC-BY-NC-ND-4.0

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

cpp2: namespace = {

regex: namespace = {

view: <CharT> type == std::basic_string_view<CharT>;
bstring: <CharT> type == std::basic_string<CharT>;

match_group: @struct <Iter> type = {
    start: Iter = ();
    end: Iter = ();

    matched: bool = false;
}

match_context: <CharT, Iter, max_groups: size_t> type =
{
    public groups: std::array<match_group<Iter>, max_groups> = ();

    get_group: <pos: size_t> (inout this) groups[pos]&;
}

template_list: <List...> type = {}

regular_expression: <CharT, groups: size_t, Matcher, Other ...> type = {

    Iter: type == view<CharT>::const_iterator;
    context: type == match_context<CharT, Iter, groups>;

    search: (in this, str: view<CharT>, inout ctx: context) -> bool = {
        cur := str.begin();
        end := str.end();
        while cur != end next (cur++) {
            if Matcher::match(cur, cur, end, ctx, template_list<Other...>()) {
                return true;
            }
        }

        return false;
    }

    to_string: (in this) -> _ = Matcher::to_string();
}

end_matcher_logic: type =
{
    match: <Iter> (begin: Iter, cur: Iter, end: Iter, inout ctx, _) -> bool = {
        return true;
    }
}

char_matcher_logic: <CharT, C: CharT> type =
{
    match: <Iter, First, Other ...> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : template_list<First, Other...>) -> bool = {
        if cur != end && cur* == C {
            return First::match(begin, cur + 1, end, ctx, template_list<Other...>());
        } else {
            return false;
        }
    }
}

regex_parser_state: @struct type = {
    cur_match_list: std::vector<std::string> = ();
    alternate_match_lists: std::vector<std::vector<std::string>> = ();

    start_new_list: (inout this) = {
        new_list: std::vector<std::string> = ();
        std::swap(new_list, cur_match_list);
        _ = alternate_match_lists.insert(alternate_match_lists.begin(), new_list);
    }

    swap: (inout this, inout t: regex_parser_state) = {
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
    }

    add: (inout this, matcher: _) = {
        cur_match_list.push_back(matcher);
    }

    wrap_last: (inout this, matcher) = {
        last: std::string = cur_match_list.back();
        cur_match_list.back() = matcher(last);
        _ = matcher;
        _ = last;
    }

    empty: (this) -> bool = cur_match_list.empty();
}


regex_parser: <Error_out> type = {

    regex: std::string_view;
    cur_state: regex_parser_state = ();
    pos: size_t = 0;

    named_groups: int = 1; // Global capture group.

    error_out: Error_out;

    operator=: (out this, r: std::string_view, e: Error_out) = {
        this.regex = r;
        this.error_out = e;
    }

    parse_until:(inout this, term: char) = {
        while pos != regex.size() next pos += 1 {
            c: char = regex[pos];

            if c == term { return; }

            // if is_alternative(c) { continue; }
            // if is_any(c) { continue; }
            // if is_class(c) { continue; }
            // if is_escape(c) { continue; }
            // if is_anchor(c) { continue; }
            // if is_group(c) { continue; }
            // if is_handle_special(c) { continue; }
            // if is_range(c) { continue; }
            // if is_special_range(c) { continue; }

            // No special char push a character match
            cur_state.add("::cpp2::regex::char_matcher_logic<char, '(c)$'>");
        }
    }

    private join: (list: std::vector<std::string>) -> std::string = {
        r: std::string = "";

        seperator: std::string = "";
        for list do (cur) {
            r += seperator + cur;
            seperator = ", ";
        }

        return r;
    }

    create_matcher_from_state: (inout this) -> std::string = {
        return join(cur_state.cur_match_list);
    }

    parse:(inout this) -> std::string = {

        parse_until('\0');

        inner := create_matcher_from_state();
        return "::cpp2::regex::regular_expression<char, (named_groups)$, (inner)$, ::cpp2::regex::end_matcher_logic>";
    }

}

generate_template: <Err> (regex: std::string_view, err: Err) -> std::string = {
    parser: regex_parser<Err> = (regex, err);
    r := parser.parse();
    _ = parser;
    return r;
}

}
}
