
//  Copyright (c) Herb Sutter
//  SPDX-License-Identifier: CC-BY-NC-ND-4.0

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

cpp2: namespace = {

regex: namespace = {

view: <CharT> type == std::basic_string_view<CharT>;
bstring: <CharT> type == std::basic_string<CharT>;

match_group: @struct <Iter> type = {
    start: Iter = ();
    end: Iter = ();

    matched: bool = false;
}

match_context: <CharT, Iter, max_groups: size_t> type =
{
    public groups: std::array<match_group<Iter>, max_groups> = ();

    set_group_start: (inout this, pos, start) = {
        groups[pos].start = start;
    }

    set_group_end: (inout this, pos, end) = {
        groups[pos].end = end;
        groups[pos].matched = true;
    }

    get_group: (inout this, pos) groups[pos]&;
}

matcher_list: <List...> type = {
    match: <Iter> (begin: Iter, cur: Iter, end: Iter, inout ctx) select<Iter, List...>(begin, cur, end, ctx);

    match_combine: <Iter, OtherList...> (begin: Iter, cur: Iter, end: Iter, inout ctx, _: matcher_list<OtherList...>)
        select<Iter, List..., OtherList...>(begin, cur, end, ctx);

    private select: <Iter, First, Other...> (begin: Iter, cur: Iter, end: Iter, inout ctx)
        First::match(begin, cur, end, ctx, matcher_list<Other...>());
    private select: <Iter> (begin: Iter, cur: Iter, end: Iter, inout ctx) true;
}

regular_expression: <CharT, groups: size_t, Matcher> type = {

    Iter: type == view<CharT>::const_iterator;
    context: type == match_context<CharT, Iter, groups>;

    search: (in this, str: view<CharT>, inout ctx: context) -> bool = {
        cur := str.begin();
        end := str.end();
        while cur != end next (cur++) {
            if Matcher::match(cur, cur, end, ctx) {
                return true;
            }
        }

        return false;
    }

    to_string: (in this) -> _ = Matcher::to_string();
}

alternative_matcher_logic: <CharT, List ...> type = {

    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) match_all<Iter, Other, List...>(begin, cur, end, ctx, Other());
    private match_all: <Iter, Tail, First, Other ...> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Tail) -> bool = {
        if First::match(begin, cur, end, ctx, Tail()) {
            return true;
        } else {
            if constexpr 0 != sizeof...(Other) {
                return match_all<Iter, Tail, Other...>(begin, cur, end, ctx, Tail());
            } else {
                return false;
            }
        }
    }
}

char_matcher_logic: <CharT, C: CharT> type =
{
    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) -> bool = {
        if cur != end && cur* == C {
            return Other::match(begin, cur + 1, end, ctx);
        } else {
            return false;
        }
    }
}

group_matcher_start_logic: <CharT, group: int> type = {
    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) -> bool = {
        ctx.set_group_start(group, cur);
        return Other::match(begin, cur, end, ctx);
    }
}

group_matcher_end_logic: <CharT, group: int> type = {
    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) -> bool = {
        ctx.set_group_end(group, cur);
        return Other::match(begin, cur, end, ctx);
    }
}

list_matcher_logic: <CharT, List> type =
{
    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) -> bool = {
        return List::match_combine(begin, cur, end, ctx, Other());
    }
}


regex_parser_state: @struct type = {
    cur_match_list: std::vector<std::string> = ();
    alternate_match_lists: std::vector<std::vector<std::string>> = ();

    start_new_list: (inout this) = {
        new_list: std::vector<std::string> = ();
        std::swap(new_list, cur_match_list);
        _ = alternate_match_lists.insert(alternate_match_lists.begin(), new_list);
    }

    swap: (inout this, inout t: regex_parser_state) = {
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
    }

    add: (inout this, matcher: _) = {
        cur_match_list.push_back(matcher);
    }

    wrap_last: (inout this, matcher) = {
        last: std::string = cur_match_list.back();
        cur_match_list.back() = matcher(last);
        _ = matcher;
        _ = last;
    }

    empty: (this) -> bool = cur_match_list.empty();
}


regex_parser: <Error_out> type = {

    regex: std::string_view;
    cur_state: regex_parser_state = ();
    pos: size_t = 0;

    named_groups: int = 1; // Global capture group.

    error_out: Error_out;

    operator=: (out this, r: std::string_view, e: Error_out) = {
        this.regex = r;
        this.error_out = e;
    }

    is_alternative: (inout this, c: char) -> bool = {
        if c != '|' { return false; }

        cur_state.start_new_list();
        return true;
    }

    parse_until:(inout this, term: char) = {
        while pos != regex.size() next pos += 1 {
            c: char = regex[pos];

            if c == term { return; }

            if is_alternative(c) { continue; }
            // if is_any(c) { continue; }
            // if is_class(c) { continue; }
            // if is_escape(c) { continue; }
            // if is_anchor(c) { continue; }
            // if is_group(c) { continue; }
            // if is_handle_special(c) { continue; }
            // if is_range(c) { continue; }
            // if is_special_range(c) { continue; }

            // No special char push a character match
            cur_state.add("::cpp2::regex::char_matcher_logic<char, '(c)$'>");
        }
    }

    private join: (list: std::vector<std::string>) -> std::string = {
        r: std::string = "";

        seperator: std::string = "";
        for list do (cur) {
            r += seperator + cur;
            seperator = ", ";
        }

        return r;
    }

    create_matcher_from_list: (inout this, list)
            "::cpp2::regex::list_matcher_logic<char, ::cpp2::regex::matcher_list<(join(list))$>>"

    create_matcher_from_state: (inout this) -> std::string = {
        if 0 == cur_state.alternate_match_lists.size() { return create_matcher_from_list(cur_state.cur_match_list); }

        matcher: std::string = "::cpp2::regex::alternative_matcher_logic<char, ";

        seperator: std::string = "";
        add := :(list) = {
            matcher&$* += seperator&$* + create_matcher_from_list(list);
            seperator&$* = ", ";
        };

        cur := cur_state.alternate_match_lists.rbegin();
        while cur != cur_state.alternate_match_lists.rend() next( cur++ ) {
            add(cur*);
        }
        if 0 != cur_state.cur_match_list.size() { add(cur_state.cur_match_list); }
        matcher += ">";

        return matcher;
    }

    parse:(inout this) -> std::string = {

        parse_until('\0');

        inner := create_matcher_from_state();
        inner = "::cpp2::regex::group_matcher_start_logic<char, 0>, (inner)$, ::cpp2::regex::group_matcher_end_logic<char, 0>";
        return "::cpp2::regex::regular_expression<char, (named_groups)$, ::cpp2::regex::matcher_list<(inner)$>>";
    }

}

generate_template: <Err> (regex: std::string_view, err: Err) -> std::string = {
    parser: regex_parser<Err> = (regex, err);
    r := parser.parse();
    _ = parser;
    return r;
}

}
}
