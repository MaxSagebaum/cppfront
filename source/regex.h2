
//  Copyright (c) Herb Sutter
//  SPDX-License-Identifier: CC-BY-NC-ND-4.0

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#include <map>

cpp2: namespace = {

regex: namespace = {

greedy_alternative : bool == false;

view: <CharT> type == std::basic_string_view<CharT>;
bstring: <CharT> type == std::basic_string<CharT>;

//-----------------------------------------------------------------------
//
//  Helper structures for the expression matching.
//
//-----------------------------------------------------------------------
//

expression_flags: type = {
    case_insensitive : int == 1;  // mod: i
    multiple_lines: int    == 2;  // mod: m
    single_line: int       == 4;  // mod: s
}

match_group: @struct <Iter> type = {
    start: Iter = ();
    end: Iter = ();

    matched: bool = false;
}

match_return: @struct <Iter> type = {
    matched: bool = false;
    pos: Iter = ();
}

match_context: <CharT, Iter, max_groups: int, max_alternatives: int> type =
{
    public begin: Iter;
    public end: Iter;

    private groups: std::array<match_group<Iter>, max_groups> = ();
    private alternatives_pos: std::array<Iter, max_alternatives> = ();

    operator=: (out this, begin_: Iter, end_: Iter) = {
        begin = begin_;
        end = end_;
    }

    operator=: (out this, that) = {}

    // Getter and setter for groups
    //
    get_group: (in this, group) groups[group];

    get_group_string: (in this, group) -> std::string = {
        if group >= max_groups {
            return "";
        }
        return std::string(groups[group].start, groups[group].end);
    }
    get_group_start:  (in this, group) std::distance(begin, groups[group].start);
    get_group_end:    (in this, group) std::distance(begin, groups[group].end);

    set_group_end: (inout this, group, pos) = {
        groups[group].end = pos;
        groups[group].matched = true;
    }

    set_group_invalid: (inout this, group) = {
        groups[group].matched = false;
    }

    set_group_start: (inout this, group, pos) = {
        groups[group].start = pos;
    }

    size: (in this) max_groups;

    // Getter and setter for alternatives

    get_alternative_pos: (in this, alternative) alternatives_pos[alternative];

    set_alternative_pos: (inout this, alternative, pos) = {
        alternatives_pos[alternative] = pos;
    }

    // Misc functions
    //
    print_ranges: (in this) -> bstring<CharT> = {
        r: bstring<CharT> = "";
        for groups do (cur) {
            if cur.matched {
                r += "((std::distance(begin, cur.start))$,(std::distance(begin, cur.end))$)";
            }
            else {
                r += "(?,?)";
            }
        }

        return r;
    }
}

match_modifiers_state_change: <has_change_: bool, reset_: bool, add_: int, remove_: int, str: fixed_string> type = {

    reset: bool == reset_;
    add: int == add_;
    remove: int == remove_;
    has_change: bool == has_change_;

    combine_inner: (old_flags: int) -> _ == {
        new_flags := old_flags;
        if reset {
            new_flags = 0;
        }
        new_flags = new_flags | add;
        new_flags = new_flags & (remove~);

        return new_flags;
    }

    to_string: () str.data();
}

match_modifiers_no_change : type == match_modifiers_state_change<false, false, 0, 0, "">;

match_modifiers: <flags_: int, Inner> type = {

    flags : int == flags_;

    // Push/pop management

    push: <Change>   (_ : Change) match_modifiers<Change::combine_inner(flags), match_modifiers<flags, Inner>>();
    pop:             ()           Inner();
    replace: <Change>(_ : Change) match_modifiers<Change::combine_inner(flags), Inner>();

    // Flag management
    //

    has_flag: (this, f: int) -> bool = {
        return  0 != (f & flags);
    }
}

//  Represents the remainder of the regular expression.
//
//  A matcher can ask this remainder if it would match. If yes a full match of the regular expression is found.
//  Otherwise the matcher can try a different alternative.
//
matcher_list: <CharT, List...> type = {
    match: (cur, inout ctx, modifiers) match_select<List...>(cur, ctx, modifiers);

    match: <OtherList...> (cur, inout ctx, modifiers, _: matcher_list<CharT, OtherList...>)
        match_select<List..., OtherList...>(cur, ctx, modifiers);

    private match_select: <First, Other...> (cur, inout ctx, modifiers)
        First::match(cur, ctx, modifiers, matcher_list<CharT, Other...>());
    private match_select: (cur, inout ctx, modifiers) match_return(true, cur);

    reset_ranges: ( inout ctx) = (List::reset_ranges(ctx), ...);
    to_string: () (bstring<CharT>() + ... + List::to_string());

    prepend: <Pre> (_ : Pre) matcher_list<CharT, Pre, List...>();
}

no_tail: <CharT> type == matcher_list<CharT>;

//-----------------------------------------------------------------------
//
//  Character classes for regular expressions.
//
//-----------------------------------------------------------------------
//

// Class syntax: <any character> Example: a
//
single_class_entry: <CharT, C: CharT> type =
{
    includes: (c: CharT) c == C;
    to_string: ()        bstring<CharT>(1, C);
}

// Class syntax: - Example: a-c
//
range_class_entry: <CharT, Start: CharT, End: CharT> type =
{
    includes: (c: CharT) Start <= c <= End;
    to_string:        () "(Start)$-(End)$";
}

// Helper for combining two character classes
//
combined_class_entry: <CharT, List ...> type = {
    includes: (c: CharT) (false || ... || List::includes(c));
    to_string: ()        ("" + ... + List::to_string());
}

// Class syntax: <list of characters>  Example: abcd
//
list_class_entry: <CharT, List ... : CharT> type = {
    includes: (c: CharT) (false || ... || (List == c));
    to_string: ()        ("" + ... + List);
}

// Class syntax: [:<class name:]  Example: [:alnum:]
//
named_class_entry: <CharT, Name: fixed_string, Inner> type = {
    includes: (c: CharT) Inner::includes(c);
    to_string: ()        "[:(Name.data())$:]";
}

negated_class_entry: <CharT, Inner> type = {
    this: Inner = ();
    includes: (c: CharT) !Inner::includes(c);
}

// Short class syntax: \<character>  Example: \w
//
shorthand_class_entry: <CharT, Name: fixed_string, Inner> type = {
    includes: (c: CharT) Inner::includes(c);
    to_string: ()        bstring<CharT>(Name.data());
}


// Named basic character classes
//
digits_class  : <CharT> type == named_class_entry<CharT, "digits", range_class_entry<CharT, '0', '9'>>;
lower_class   : <CharT> type == named_class_entry<CharT, "lower", range_class_entry<CharT, 'a', 'z'>>;
upper_class   : <CharT> type == named_class_entry<CharT, "upper", range_class_entry<CharT, 'A', 'Z'>>;

// Named other classes
//
alnum_class     : <CharT> type == named_class_entry<CharT, "alnum", combined_class_entry<CharT, lower_class<CharT>, upper_class<CharT>, digits_class<CharT>>>;
alpha_class     : <CharT> type == named_class_entry<CharT, "alpha", combined_class_entry<CharT, lower_class<CharT>, upper_class<CharT>>>;
ascii_class     : <CharT> type == named_class_entry<CharT, "ascii", range_class_entry<CharT, '\x00', '\x7F'>>;
blank_class     : <CharT> type == named_class_entry<CharT, "blank", list_class_entry<CharT, ' ', '\t'>>;
cntrl_class     : <CharT> type == named_class_entry<CharT, "cntrl", combined_class_entry<CharT, range_class_entry<CharT, '\x00', '\x1F'>, single_class_entry<CharT, '\x7F'>>>;
graph_class     : <CharT> type == named_class_entry<CharT, "graph", range_class_entry<CharT, '\x21', '\x7E'>>;
hor_space_class : <CharT> type == named_class_entry<CharT, "hspace", list_class_entry<CharT, '\t', ' '>>;
print_class     : <CharT> type == named_class_entry<CharT, "print", range_class_entry<CharT, '\x20', '\x7E'>>;
punct_class     : <CharT> type == named_class_entry<CharT, "punct", list_class_entry<CharT, '[','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/',':',';','<','=','>','?','@','[','\\',']','^','_','`','{','|','}','~',']'>>;
space_class     : <CharT> type == named_class_entry<CharT, "space", list_class_entry<CharT, ' ', '\t', '\r', '\n', '\v', '\f'>>;
ver_space_class : <CharT> type == named_class_entry<CharT, "vspace", list_class_entry<CharT, '\n', '\v', '\f', '\r'>>;
word_class      : <CharT> type == named_class_entry<CharT, "word", combined_class_entry<CharT, alnum_class<CharT>, single_class_entry<CharT, '_'>>>;
xdigit_class    : <CharT> type == named_class_entry<CharT, "xdigit", combined_class_entry<CharT, range_class_entry<CharT, 'A', 'F'>, range_class_entry<CharT, 'a', 'f'>, digits_class<CharT>>>;

// Shorthand class entries
//
short_digits_class     : <CharT> type == shorthand_class_entry<CharT, "\\d", digits_class<CharT>>;
short_hor_space_class  : <CharT> type == shorthand_class_entry<CharT, "\\h", hor_space_class<CharT>>;
short_space_class      : <CharT> type == shorthand_class_entry<CharT, "\\s", space_class<CharT>>;
short_vert_space_class : <CharT> type == shorthand_class_entry<CharT, "\\v", ver_space_class<CharT>>;
short_word_class       : <CharT> type == shorthand_class_entry<CharT, "\\w", word_class<CharT>>;


short_not_digits_class     : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\D", digits_class<CharT>>>;
short_not_hor_space_class  : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\H", hor_space_class<CharT>>>;
short_not_space_class      : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\S", space_class<CharT>>>;
short_not_vert_space_class : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\V", ver_space_class<CharT>>>;
short_not_word_class       : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\W", word_class<CharT>>>;

//-----------------------------------------------------------------------
//
//  Matchers for regular expressions.
//
//-----------------------------------------------------------------------
//


// Helper for greedy alternatives
//
extract_position_helper: <CharT, alternative: size_t> type = {
    match: <Other> (cur, inout ctx, modifiers, _ : Other) -> _ = {
        r := Other::match(cur, ctx, modifiers);
        if r.matched {
            ctx.set_alternative_pos(alternative, cur);
        }
        return r;
    }

    reset_ranges: (inout ctx) = {}
    to_string: () -> _ = {}
}

//  Regex syntax: |  Example: ab|ba
//
//  Non greedy implementation. First alternative that matches is chosen. 
//
alternative_matcher_logic: <CharT, alternative: size_t, List ...> type = {

    match: <Tail> (cur, inout ctx, modifiers, tail: Tail) -> _ = {
        if constexpr greedy_alternative {
            max_overall_length: = 0;
            max_current_length: = 0;
            r := match_greedy<Tail, List...>(cur, max_overall_length, max_current_length, ctx, modifiers, tail);
            _ = max_overall_length;
            _ = max_current_length;
            return r;
        } else {
            return match_first<List...>(cur, ctx, modifiers, tail);
        }
    }
    reset_ranges: (inout ctx)     = (List::reset_ranges(ctx) , ...);
    to_string: ()                   (bstring<CharT>() + ... + ("|" + List::to_string())).substr(1); // substr: Remove first '|'.

    private match_first: <First, Next ...> (cur, inout ctx, modifiers, tail) -> _ = {
        r := First::match(cur, ctx, modifiers, tail);
        if r.matched {
            return r;
        } else {
            First::reset_ranges(ctx);

            if constexpr 0 != sizeof...(Next) {
                return match_first<Next...>(cur, ctx, modifiers, tail);
            } else {
                return match_return(false, ctx.end);
            }
        }
    }

    private match_greedy: <Tail, First, Next...> (cur, inout max_overall_length, inout max_current_length, inout ctx, modifiers, _: Tail) -> _ = {
        r := First::match(cur, ctx, modifiers, Tail::prepend(extract_position_helper<CharT, alternative>()));

        // Get the end position of First.
        end_overall_pos := cur;
        end_current_pos := cur;
        if r.matched {
            end_overall_pos = r.pos;
            end_current_pos = ctx.get_alternative_pos(alternative);
        }

        // Compute the new max length and our max length.
        my_overall_length := unsafe_narrow<int>(std::distance(cur, end_overall_pos));
        max_overall_length = std::max(max_overall_length, my_overall_length);


        // Check if someone other has something larker
        o := match_return(false, ctx.end);
        if constexpr 0 != sizeof...(Next) {
            o = match_greedy<Tail, Next...>(cur, max_overall_length, max_current_length, ctx, modifiers, Tail());
        }

        my_current_length := unsafe_narrow<int>(std::distance(cur, end_current_pos));
        if max_overall_length == my_overall_length {
            max_current_length = std::max(max_current_length, my_current_length);
        }


        if r.matched && my_overall_length == max_overall_length {
            // We are the longest. Check now if we are also the longest in this alternative.
            if my_current_length == max_current_length {
                // Yes we are. Reset all groups by matching again.
                (Next::reset_ranges(ctx) , ...); // Reset all other ranges.
                return First::match(cur, ctx, modifiers, Tail::prepend(extract_position_helper<CharT, alternative>()));
            }
            else {
                // We are not, so there was an other match.
                First::reset_ranges(ctx);

                return o;
            }
        } else {
            // We are not the largest one.
            First::reset_ranges(ctx);

            return o;
        }
    }
}

//  Regex syntax: .
//
any_matcher_logic: <CharT> type =
{
    match: <Other> (cur, inout ctx, modifiers, _ : Other) -> _ = {
        if cur != ctx.end &&
          (modifiers.has_flag(expression_flags::single_line) ||
           cur* != '\n') {
            return Other::match(cur + 1, ctx, modifiers);
        }
        else {
            return match_return(false, ctx.end);
        }
    }

    reset_ranges: (inout ctx) = {}
    to_string: ()               bstring<CharT>(1, '.');
}

// Regex syntax: <any character>  Example: a
//
char_matcher_logic: <CharT, C: CharT, L: CharT, U: CharT> type =
{
    match: <Other> (cur, inout ctx, modifiers, _ : Other) -> _ = {
        if modifiers.has_flag(expression_flags::case_insensitive) {
            if cur != ctx.end && (cur* == L || cur* == U) {
                return Other::match(cur + 1, ctx, modifiers);
            }
            else {
                return match_return(false, ctx.end);
            }
        }
        else {
            if cur != ctx.end && cur* == C {
                return Other::match(cur + 1, ctx, modifiers);
            }
            else {
                return match_return(false, ctx.end);
            }
        }

    }
    reset_ranges: (inout ctx) = {}
    to_string: ()               bstring<CharT>(1, C);
}


// Regex syntax: [<character classes>]  Example: [abcx-y[:digits:]]
//
class_matcher_logic: <CharT, negate: bool, List ...> type =
{
    match: <Other> (cur, inout ctx, modifiers, _ : Other) -> _ = {
        if modifiers.has_flag(expression_flags::case_insensitive) {
            if cur != ctx.end && negate != ( match_any<List...>(safe_tolower(cur*)) || match_any<List...>(safe_toupper(cur*))) {
                return Other::match(cur + 1, ctx, modifiers);
            }
            else {
                return match_return(false, ctx.end);
            }
        }
        else {
            if cur != ctx.end && negate != match_any<List...>(cur*) {
                return Other::match(cur + 1, ctx, modifiers);
            }
            else {
                return match_return(false, ctx.end);
            }
        }
    }

    private match_any: <First, Other ...> (c: CharT) -> bool = {
        r: bool = First::includes(c);

        if !r {
            if constexpr 0 != sizeof...(Other) {
                r = match_any<Other...>(c);
            }
        }

        return r;
    }

    reset_ranges: (inout ctx) = {}

    to_string: () -> bstring<CharT> = {
        r: bstring<CharT> = "[";
        if negate {
            r += "^";
        }
        r += (bstring<CharT>() + ... + List::to_string());
        r += "]";

        return r;
    }
}

// Regex syntax: none Example: -
//
empty_matcher_logic: <CharT> type = {
    match: <Other> (cur, inout ctx, modifiers, _ : Other) Other::match(cur, ctx, modifiers);
    reset_ranges: (inout ctx) = {}
    to_string: () bstring<CharT>();
}

// Regex syntax: \<special character>  Example: \.
//
escaped_char_matcher_logic: <CharT, C: CharT, L: CharT, U: CharT> type =
{
    this : char_matcher_logic<CharT, C, L, U> = ();

    to_string: () "\\(C)$";
}

// Regex syntax: \K Example: \K
//
global_group_reset: <CharT> type = {
    match: <Other> (cur, inout ctx, modifiers, _ : Other) -> _ = {
        ctx.set_group_start(0, cur);
        return Other::match(cur, ctx, modifiers);
    }

    reset_ranges: (inout ctx) = {}
    to_string: () "\\K";
}

// Regex syntax: (<inner>) Example: (.*)
//
group_matcher_start_logic: <CharT, group: int, ModifierChange, name: fixed_string> type = {
    match: <Other, Modifiers> (cur, inout ctx, _ : Modifiers, _ : Other) -> _ = {
        if -1 != group {
            ctx.set_group_start(group, cur);
        }
        return Other::match(cur, ctx, Modifiers::push(ModifierChange()));
    }

    reset_ranges: (inout ctx) = ctx.set_group_invalid(group);

    to_string: () -> std::string = {
        if group != 0 {
            if 0 != name.size() {
                return "(?<(name.data())$>";
            }
            else if ModifierChange::has_change {
                return "(?(ModifierChange::to_string())$:";
            }
            else {
                return "(";
            }
        }
        else {
            return "";
        }
    }
}

group_matcher_end_logic: <CharT, group: int> type = {
    match: <Other, Modifier> (cur, inout ctx, modifiers: Modifier, _ : Other) -> _ = {
        if -1 != group {
            ctx.set_group_end(group, cur);
        }
        r := Other::match(cur, ctx, Modifier::pop());
        if !r.matched && -1 != group {
            ctx.set_group_invalid(group);
        }
        return r;
    }

    reset_ranges: (inout ctx) = {}

    to_string: () -> _ = {
        if group != 0 {
            return ")";
        }
        else {
            return "";
        }
    }
}

// Regex syntax: \<number>  Example: \1
//
group_ref_matcher_logic: <CharT, group: int, symbol: fixed_string> type = {
    match: <Other> (cur, inout ctx, modifiers, _ : Other) -> _ = {
        g := ctx.get_group(group);

        pos := cur;
        group_pos := g.start;
        while group_pos != g.end && pos != ctx.end next (group_pos++, pos++) {
            if modifiers.has_flag(expression_flags::case_insensitive) {
                if safe_tolower(group_pos*) != safe_tolower(pos*) {
                    return match_return(false, ctx.end);
                }
            }
            else {
                if group_pos* != pos* {
                    return match_return(false, ctx.end);
                }
            }
        }

        if group_pos == g.end {
            return Other::match(pos, ctx, modifiers);
        }
        else {
            return match_return(false, ctx.end);
        }

    }
    reset_ranges: (inout ctx) = {}
    to_string: ()               bstring<CharT>(symbol.data());
}

// Regex syntax: $  Example: aa$
//
line_end_matcher_logic: <CharT, match_new_line: bool, match_new_line_before_end: bool> type =
{
    match: <Other> (cur, inout ctx, modifiers, _ : Other) -> _ = {
        if cur == ctx.end || (match_new_line && modifiers.has_flag(expression_flags::multiple_lines) && cur* == '\n') {
            return Other::match(cur, ctx, modifiers);
        }
        else if match_new_line_before_end && (cur* == '\n' && (cur + 1) == ctx.end) { // Special case for new line at end.
            return Other::match(cur, ctx, modifiers);
        }
        else {
            return match_return(false, ctx.end);
        }
    }

    reset_ranges: (inout ctx) = {}
    to_string: ()               "\\$";
}

// Regex syntax: ^  Example: ^aa
//
line_start_matcher_logic: <CharT, match_new_line: bool> type =
{
    match: <Other> (cur, inout ctx, modifiers, _ : Other) -> _ = {
        if cur == ctx.begin || (match_new_line && modifiers.has_flag(expression_flags::multiple_lines)  && (cur - 1)* == '\n') {
            return Other::match(cur, ctx, modifiers);
        }
        else {
            return match_return(false, ctx.end);
        }

    }
    reset_ranges: (inout ctx) = {}
    to_string: ()               bstring<CharT>(1, '^');
}

// Regex syntax: (?<modifiers>)  Example: (?i)
//
modifier_matcher_logic: <CharT, ModifierChange> type =
{
    match: <Other, Modifier> (cur, inout ctx, _: Modifier, _ : Other) -> _ = {
        return Other::match(cur, ctx, Modifier::replace(ModifierChange()));
    }
    reset_ranges: (inout ctx) = {}
    to_string: ()               "(?(ModifierChange::to_string())$)";
}

// Named character classes
//

named_matcher_logic: <CharT, Name: fixed_string, Base> type = {
    this: Base = ();
    to_string: () bstring<CharT>(Name.data());
}
named_class_matcher_logic: <CharT, Name: fixed_string, negate: bool, List ...> type =  {
    this: named_matcher_logic<CharT, Name, class_matcher_logic<CharT, negate, List...>> = ();
}

named_class_no_new_line: <CharT> type == named_class_matcher_logic<CharT, "\\\\N", true, single_class_entry<CharT, '\n'>>; // TODO: Remove second \, switch to raw strings.
named_class_digits     : <CharT> type == named_class_matcher_logic<CharT, "\\d", false, digits_class<CharT>>;
named_class_hor_space  : <CharT> type == named_class_matcher_logic<CharT, "\\h", false, hor_space_class<CharT>>;
named_class_space      : <CharT> type == named_class_matcher_logic<CharT, "\\s", false, space_class<CharT>>;
named_class_ver_space  : <CharT> type == named_class_matcher_logic<CharT, "\\v", false, ver_space_class<CharT>>;
named_class_word       : <CharT> type == named_class_matcher_logic<CharT, "\\w", false, word_class<CharT>>;


named_class_not_digits    : <CharT> type == named_class_matcher_logic<CharT, "\\D", true, digits_class<CharT>>;
named_class_not_hor_space : <CharT> type == named_class_matcher_logic<CharT, "\\H", true, hor_space_class<CharT>>;
named_class_not_space     : <CharT> type == named_class_matcher_logic<CharT, "\\S", true, space_class<CharT>>;
named_class_not_ver_space : <CharT> type == named_class_matcher_logic<CharT, "\\V", true, ver_space_class<CharT>>;
named_class_not_word      : <CharT> type == named_class_matcher_logic<CharT, "\\W", true, word_class<CharT>>;

// Other named matchers
named_string_end_or_before_new_line_at_end: <CharT> type == named_matcher_logic<CharT, "\\Z", line_end_matcher_logic<CharT, false, true>>;
named_string_end: <CharT> type == named_matcher_logic<CharT, "\\z", line_end_matcher_logic<CharT, false, false>>;
named_string_start: <CharT> type == named_matcher_logic<CharT, "\\A", line_start_matcher_logic<CharT, false>>;



// Regex syntax: <matcher>{min, max}  Example: a{2,4}
range_matcher_logic: <CharT, M, min_count: int, max_count: int, greedy: bool, possessive: bool> type = {

    match: <Iter> (cur: Iter, inout ctx, modifiers, tail) -> _ = {
        if greedy {
            return match_greedy(0, cur, cur, ctx, modifiers, tail);
        }
        else {
            return match_not_greedy(cur, ctx, modifiers, tail);
        }
    }

    reset_ranges: (inout ctx)     = M::reset_ranges(ctx);

    to_string: () -> bstring<CharT> = {
      r: std::string = M::to_string();

      if min_count == max_count {
        r += "{(min_count)$}";
      }
      else if min_count == -1 {
        r += "{,(max_count)$}";
      }
      else if max_count == -1 {
        r += "{(min_count)$,}";
      }
      else {
        r += "{(min_count)$,(max_count)$}";
      }

      if !greedy {
        r += "?";
      }
      else if possessive {
        r += "+";
      }

      return r;
    }

    private is_below_upper_bound: (count: int) -> bool = {
        if -1 == max_count { return true; }
        else { return count < max_count; }
    }

    private is_below_lower_bound: (count: int) -> bool = {
        if -1 == min_count { return false; }
        else { return count < min_count; }
    }

    private is_in_range: (count: int) -> bool = {
        if -1 != min_count && count < min_count { return false; }
        if -1 != max_count && count > max_count { return false; }
        return true;
    }

    private match_min_count: <Iter> (cur: Iter, inout ctx, modifiers, inout count_r: int) -> _ = { // TODO: count_r as out parameter introduces a performance loss.
        res := match_return(true, cur);
        count := 0;

        while is_below_lower_bound(count) && res.matched {
            res = M::match(res.pos, ctx, modifiers, no_tail<CharT>());
            if res.matched {
                count += 1;
            }
        }

        count_r = count;
        return res;
    }

    private match_greedy: <Iter, Other> (count: int, cur: Iter, last_valid: Iter, inout ctx, modifiers, _ : Other) -> match_return<Iter> = {
        r:= M::match(cur, ctx, modifiers, no_tail<CharT>());
        if  is_below_upper_bound(count) && r.matched &&
            (is_below_lower_bound(count) || r.pos != cur)
        {
            inner := match_greedy(count + 1, r.pos, cur, ctx, modifiers, Other());

            if possessive ||  // Do not backtrack if possessive.
               inner.matched {
                return inner;
            }
        }

        // No match from the recursion. Try to match our tail.
        if is_in_range(count) {
            o:= Other::match(cur, ctx, modifiers);

            if o.matched {
                // Rematch M to set the groups.
                M::reset_ranges(ctx);
                _ = M::match(last_valid, ctx, modifiers, no_tail<CharT>());
            }

            return o;
        }
        else {
            return match_return(false, ctx.end);
        }
    }

    private match_not_greedy: <Iter, Other> (cur: Iter, inout ctx, modifiers, _ : Other) -> match_return<Iter> = {
        count := 0;
        start := match_min_count(cur, ctx, modifiers, count);
        if !start.matched {
          return start;
        }

        pos := start.pos;
        while is_below_upper_bound(count) {
            o:= Other::match(pos, ctx, modifiers);
            if o.matched {
                return o;
            }

            r:= M::match(pos, ctx, modifiers, no_tail<CharT>());
            if !r.matched {
                return match_return(false, ctx.end);
            }
            count += 1;
            pos = r.pos;
        }

        return Other::match(pos, ctx, modifiers); // Upper bound reached.
    }
}

// Regex syntax: *, +, or ?  Example: aa*
//
special_range_matcher_logic: <CharT, M, min_count: int, max_count: int, greedy: bool, possessive: bool, symbol: char> type = {
    this: range_matcher_logic<CharT, M, min_count, max_count, greedy, possessive> = ();
    to_string: () -> _ = {
        r := M::to_string() + symbol;
        if !greedy {
            r += "?";
        }
        else if possessive {
            r += "+";
        }

        return r;
    }
}

// Regex syntax: \b or \B  Example: \bword\b
//
// Matches the start end end of word boundaries.
//
word_boundary_matcher_logic: <CharT, negate: bool> type =
{
    match: <Other> (cur, inout ctx, modifiers, _: Other) -> _ = {
        words : word_class<CharT> = ();
        is_match := false;
        if cur == ctx.begin { // String start
            if cur != ctx.end { // No empty string
                is_match = words.includes(cur*);
            }
        }
        else if cur == ctx.end { // String end
            is_match = words.includes((cur - 1)*);
        }
        else { // Middle of string
            is_match =
                   (words.includes((cur - 1)*) && !words.includes(cur*))  // End of word: \w\W
                || (!words.includes((cur - 1)*) && words.includes(cur*)); // Start of word: \W\w

        }
        if negate {
            is_match = !is_match;
        }

        if is_match{
            return Other::match(cur, ctx, modifiers);
        }
        else {
            return match_return(false, ctx.end);
        }

    }
    reset_ranges: (inout ctx) = {}
    to_string: () -> std::string = {
        if negate {
            return "\\B";
        } else {
            return "\\b";
        }
    }
}


//-----------------------------------------------------------------------
//
//  Regular expression implementation.
//
//-----------------------------------------------------------------------
//

// Helper for named groups.

group_name_list: <Name: fixed_string, group_id: int, Inner> type = {

    get_group_id: (name) -> int = {
        if name == Name.data() {
            return group_id;
        }
        else {
            return Inner::get_group_id(name);
        }
    }
}

group_name_list_end: type = {
    get_group_id: (_) -1;
}

// Regular expression implementation
regular_expression: <CharT, flags: int, groups: size_t, alternatives: size_t, named_groups, Matcher> type = {

    context: <Iter> type == match_context<CharT, Iter, groups, alternatives>;
    modifiers: type == match_modifiers<flags, int>;

    private get_iter: (str: view<CharT>, pos) -> _ = {
        if pos < str.size() {
            return str.begin() + pos;
        }
        else {
            return str.end();
        }
    }

    // TODO: Named multiple return has problems with templates.
    search_return: <Iter> type = {
        public matched: bool;
        public ctx: context<Iter>;

        operator=:(out this, matched_: bool, ctx_: context<Iter>) = {
            matched = matched_;
            ctx = ctx_;
        }

        group_number: (this) ctx.size();
        group:        (this, g: int) ctx.get_group_string(g);
        group_start:  (this, g: int) ctx.get_group_start(g);
        group_end:    (this, g: int) ctx.get_group_end(g);

        group:        (this, g: bstring<CharT>) group(get_group_id(g));
        group_start:  (this, g: bstring<CharT>) group_start(get_group_id(g));
        group_end:    (this, g: bstring<CharT>) group_end(get_group_id(g));

        private get_group_id: (this, g: bstring<CharT>) -> _ = {
            group_id := named_groups::get_group_id(g);
            if -1 == group_id {
                // TODO: Throw error.
            }
            return group_id;
        }
    }

    match: (in this, str: view<CharT>)                 match(str.begin(), str.end());
    match: (in this, str: view<CharT>, start)          match(get_iter(str, start), str.end());
    match: (in this, str: view<CharT>, start, length)  match(get_iter(str, start), get_iter(str, start + length));
    match: <Iter> (in this, start: Iter, end: Iter) -> search_return<Iter> = {
        ctx: context = (start, end);

        r := Matcher::match(start, ctx, modifiers());
        return search_return(r.matched && r.pos == end, ctx);
    }

    search: (in this, str: view<CharT>)                 search(str.begin(), str.end());
    search: (in this, str: view<CharT>, start)          search(get_iter(str, start), str.end());
    search: (in this, str: view<CharT>, start, length)  search(get_iter(str, start), get_iter(str, start + length));
    search: <Iter> (in this, start: Iter, end: Iter) -> search_return<Iter> = {
        matched := false;
        ctx: context = (start, end);

        cur:= start;
        while true next (cur++) {
            if Matcher::match(cur, ctx, modifiers()).matched {
                matched = true;
                break;
            }

            if cur == ctx.end {
                break;
            }
        }

        return search_return(matched, ctx);
    }

    to_string: (in this) -> _ = Matcher::to_string();
}

//-----------------------------------------------------------------------
//
//  Parser for regular expression.
//
//-----------------------------------------------------------------------
//

regex_parser_state: @struct type = {

    // Current list of matchers
    cur_match_list: std::vector<std::string> = ();

    /// List of alternate matcher lists. E.g. ab|cd|xy
    alternate_match_lists: std::vector<std::vector<std::string>> = ();

    next_alternative: (inout this) = {
        new_list: std::vector<std::string> = ();
        std::swap(new_list, cur_match_list);
        _ = alternate_match_lists.insert(alternate_match_lists.end(), new_list);
    }

    swap: (inout this, inout t: regex_parser_state) = {
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
    }

    add: (inout this, matcher: _) = cur_match_list.push_back(matcher);

    wrap_last: (inout this, matcher) = {
        last:= cur_match_list.back();
        cur_match_list.back() = matcher(last);
        _ = matcher;
        _ = last;
    }

    empty: (this) -> bool = cur_match_list.empty();
}


regex_parser: <Error_out> type = {

    regex: std::string_view;
    modifier: std::string_view;
    cur_state: regex_parser_state = ();
    pos: size_t = 0;

    next_group_id: int = 1; // Global capture group.
    alternatives_count: int = 0;

    named_groups : std::map<std::string, int> = ();

    has_error: bool = false;
    error_out: Error_out;

    supported_classes: std::vector<std::string> = ("alnum", "alpha", "ascii", "blank", "cntrl", "digits", "graph",
                                                   "lower", "print", "punct", "space", "upper", "word", "xdigit");

    operator=: (out this, r: std::string_view, m: std::string_view, e: Error_out) = {
        this.regex = r;
        this.modifier = m;
        this.error_out = e;
    }

    // State management functions
    //
    new_state: (inout this) -> regex_parser_state = {
        old_state: regex_parser_state = ();
        old_state.swap(cur_state);
        return old_state;
    }

    restore_state: (inout this, old_state: regex_parser_state) = {
        cur_state = old_state;
    }

    // Position management functions
    //

    next: (inout this, out n: char) -> bool = {
        if (pos + 1) < regex.size() {
            pos += 1;
            n = regex[pos];
            return true;
        }
        else {
            n = '\0';
            return false;
        }
    }

    skip: (inout this) -> bool = {
        c: char;
        r := next(out c);
        _ = c;
        return r;
    }

    current: (in this) -> char = {
        if pos < regex.size() {
            return regex[pos];
        } else {
            return '\0';
        }
    }

    peek: (inout this) -> char = {
        if (pos + 1) < regex.size() {
            return regex[pos + 1];
        }
        else {
            return '\0';
        }
    }

    grab_until: (inout this, in e: char, out r: std::string) grab_until_one_of(std::string(1, e), out r);

    grab_until_one_of: (inout this, in e: std::string, out r: std::string) -> bool = {
        start := pos;
        end: = regex.find_first_of(e, pos);

        if end != std::string_view::npos {
            r = regex.substr(start, end - pos);
            pos = end;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_number: (inout this) -> std::string = {
        start := pos;
        start_search := pos;
        if regex[start_search] == '-' {
            start_search += 1;
        }
        end := regex.find_first_not_of("1234567890", start_search);

        r : std::string;
        if end != std::string_view::npos {
            r = regex.substr(start, end - start);
            pos = end - 1;
        }
        else {
            r = regex.substr(start);
            pos = regex.size() - 1;
        }
        return r;
    }

    // Misc functions
    //
    error:(inout this, message: std::string) = {
        error_out("Error during parsing of regex '(regex)$' at position '(pos)$': (message)$");
        has_error = true;
    }

    create_matcher: (in this, name: std::string, template_arguments: std::string) -> _ = {
        sep := ", ";
        if template_arguments.empty() { sep = ""; }

        return "::cpp2::regex::(name)$<char(sep)$(template_arguments)$>";
    }

    create_matcher_from_list: (inout this, list) create_matcher("matcher_list", join(list));

    create_matcher_from_state: (inout this) -> std::string = {
        if 0 == cur_state.alternate_match_lists.size() { return create_matcher_from_list(cur_state.cur_match_list); }

        if 0 == cur_state.cur_match_list.size() {
            cur_state.add(create_matcher("empty_matcher_logic", ""));
        }
        cur_state.next_alternative();

        list: std::string = "";
        separator: std::string = "";
        for cur_state.alternate_match_lists do (cur) {
            list += separator + create_matcher_from_list(cur);
            separator = ", ";
        }

        alternative_id := alternatives_count;
        alternatives_count += 1;

        return create_matcher("alternative_matcher_logic", "(alternative_id)$, (list)$");
    }

    create_named_groups_arg: (in this) -> std::string = {
        r : std::string = "::cpp2::regex::group_name_list_end";

        for named_groups do (cur) {
            r = "::cpp2::regex::group_name_list<\"(cur.first)$\", (cur.second)$, (r)$>";
        }

        return r;
    }

    join: (list: std::vector<std::string>) -> std::string = {
        r: std::string = "";

        separator: std::string = "";
        for list do (cur) {
            r += separator + cur;
            separator = ", ";
        }

        return r;
    }

    parse_modifiers: (inout this, change_str: std::string, out modifier_change: std::string) -> bool = {
        is_negative := false;
        is_reset    := false;

        add    := 0;
        remove := 0;

        apply := :(flag: int) = {
            if is_negative&$* {
                remove&$* += flag;
            }
            else {
                add&$* += flag;
            }
        };

        for change_str do (cur) {
            if cur == '^' {
                is_reset = true;
            }
            else if cur == '-' {
                if is_reset { error("No negative modifier allowed."); return false; }
                is_negative = true;
            }
            else if cur == 'i' { apply(expression_flags::case_insensitive); }
            else if cur == 'm' { apply(expression_flags::multiple_lines); }
            else if cur == 's' { apply(expression_flags::single_line); }
            else {
                error("Unknown modifier: (cur)$"); return false;
            }
        }

        modifier_change = "::cpp2::regex::match_modifiers_state_change<true, (is_reset)$, (add)$, (remove)$, \"(change_str)$\">";

        return true;
    }

    // Parsing functions
    //

    is_alternative: (inout this, c: char) -> bool = {
        if c != '|' { return false; }

        cur_state.next_alternative();
        return true;
    }

    is_anchor: (inout this, c: char) -> bool = {
        if c == '^' {
            cur_state.add(create_matcher("line_start_matcher_logic", "true"));
            return true;
        }
        else if c == '$' {
            cur_state.add(create_matcher("line_end_matcher_logic", "true, true"));
            return true;
        }

        return false;
    }

    is_any: (inout this, c: char) -> bool = {
        if c == '.' {
            cur_state.add(create_matcher("any_matcher_logic", ""));
            return true;
        }
        return false;
    }

    is_class: (inout this, c: char) -> bool = {
        if c != '[' { return false; }

        classes: std::vector<std::string> = ();

        c_cur: char = regex[pos];
        next_item:= :() -> bool = {
            pos&$* += 1;
            if pos&$* >= regex$.size() { return false; }

            c_cur&$* = regex$[pos&$*];
            return true;

        };

        peek_item:= :() -> char = {
            if (pos$ + 1) >= regex$.size() { return '\0'; }
            else { return regex[pos + 1]; }
        };

        // First step: parse until the end bracket and push single chars, ranges or groups on the class stack.
        negate:= false;
        first:= true;
        range:= false;
        while next_item() & (c_cur != ']' || first) {
            if c_cur == '^' {
                negate = true;
                continue; // Skip rest of the loop. Also the first update.
            }
            if c_cur == '[' && peek_item() == ':' {
                // We have a character class.
                pos += 2; // Skip ':]'

                end := regex.find(":]", pos);
                if end == std::string::npos { error("Could not find end of character class."); return false; }

                name := regex.substr(pos, end - pos);
                if supported_classes.end() == std::find(supported_classes.begin(), supported_classes.end(), name) {
                    error("Unsupported character class. Supported ones are: (join(supported_classes))$");
                    return false;
                }

                classes.push_back("[:(name)$:]");

                end += 1; // Skip ':' pointing to the ending ']'.
                pos = end;
            }
            else if c_cur == '\\' {
                if next_item()  && (c_cur != ']') {
                    name := "";
                         if 'd' == c_cur { name = "short_digits"; }
                    else if 'D' == c_cur { name = "short_not_digits"; }
                    else if 'h' == c_cur { name = "short_hor_space"; }
                    else if 'H' == c_cur { name = "short_not_hor_space"; }
                    else if 's' == c_cur { name = "short_space"; }
                    else if 'S' == c_cur { name = "short_not_space"; }
                    else if 'v' == c_cur { name = "short_ver_space"; }
                    else if 'V' == c_cur { name = "short_not_ver_space"; }
                    else if 'w' == c_cur { name = "short_word"; }
                    else if 'W' == c_cur { name = "short_not_word"; }
                    else {
                        error("Unknown group escape.");
                        return false;
                    }
                    classes.push_back("[:(name)$:]");
                } else {
                    error("Escape without a following character.");
                    return false;
                }
            }
            else if c_cur == '-' {
                if first { // Literal if first entry.
                    classes.push_back("(c_cur)$");
                } else {
                    range = true;
                }
            }
            else {
                if range { // Modify last element to be a range.
                    classes.back() += "-(c_cur)$";
                    range = false;
                }
                else {
                    classes.push_back("(c_cur)$");
                }
            }

            first = false;
        }

        _ = next_item; // TODO: Use in while is not recognized.

        if c_cur != ']' {
            error("Error end of character class definition before terminating ']'.");
            return false;
        }

        if range { // If '-' is last entry treat it as a literal char.
            classes.push_back("-");
        }

        // Second step: Wrap the item on the class stack with corresponding class implementation.
        for classes do (inout cur) {
            if cur.starts_with("[:") {
                name := cur.substr(2, cur.size() - 4);
                cur = create_matcher("(name)$_class", "");
            }
            else if 1 != cur.size() {
                cur = create_matcher("range_class_entry", "'(cur[0])$', '(cur[2])$'");
            }
            else {
                cur = create_matcher("single_class_entry", "'(cur)$'");
            }
        }

        inner := join(classes);
        cur_state.add(create_matcher("class_matcher_logic", "(negate)$, (inner)$"));
        return true;
    }

    is_escape: (inout this, c: char) -> bool = {
        if c != '\\' { return false; }

        start := pos; // Keep start for group matchers.
        pos += 1;

        add_group_matcher:= :(name: std::string) -> bool = {

            group_id : int = 0;
            if string_to_int(name, group_id) {
                if group_id < 0 {
                    group_id = next_group_id + group_id;

                    if group_id < 1 { // Negative and zero are no valid groups.
                        error("Relative group reference does not reference a valid group. (Would be (group_id)$.)");
                        return false;
                    }
                }

                if group_id >= next_group_id { error("Group reference is used before the group is declared."); return false; }
            }
            else {
                // Named group
                iter := named_groups.find(name);
                if iter == named_groups.end() { error("Group names does not exist. (Name is: (name)$)"); return false; }

                group_id = iter*.second;
            }
            cur_state.add(create_matcher("group_ref_matcher_logic", "(group_id)$, \"\\(regex.substr(start$, pos&$* - start$ + 1))$\""));

            return true;
        };

        if pos >= regex.size() { error("Escape without a following character."); return false;}

        c_next: char = regex[pos];

        if '1' <= c_next <= '9' {
            group := grab_number();
            if !add_group_matcher(group) { return false; }
        }
        else if std::string::npos != std::string("tnrfae").find(c_next) {
            inner := create_matcher("char_matcher_logic", "'\\(c_next)$', '\\(c_next)$', '\\(c_next)$'");
            cur_state.add(create_matcher("named_matcher_logic", "\"\\\\(c_next)$\", (inner)$"));
        }
        else if std::string::npos != std::string("^.[]$()*{}?+|").find(c_next) {
            if c_next == '$' {
                // TODO: Provide proper escape for cppfront capture
                cur_state.add(create_matcher("line_end_matcher_logic", "true, true"));
            }
            else {
                cur_state.add(create_matcher("escaped_char_matcher_logic", "'(c_next)$', '(safe_tolower(c_next))$', '(safe_toupper(c_next))$'"));
            }
        }
        else if '\\' == c_next {
            cur_state.add(create_matcher("escaped_char_matcher_logic", "'\\\\', '\\\\', '\\\\'"));
        }
        else if 'g' == c_next {
            if !next(out c_next) {error("Group escape without a following char."); return false; }

            group : std::string = "";
            if c_next == '{' {
                if !(next(out c_next) && grab_until('}', out group)) { error("No ending bracket."); return false; }
            }
            else {
                group = grab_number();
            }
            if !add_group_matcher(group) { return false; }
        }
        else if 'k' == c_next {
            if !next(out c_next) {error("Group escape without a following char."); return false; }

            term_char := '\0';
            if c_next == '{' { term_char = '}'; }
            else if c_next == '<' { term_char = '>'; }
            else if c_next == '\'' { term_char = '\''; }
            else {
                error("Group escape has wrong operator."); return false;
            }

            group : std::string = "";
            if !(next(out c_next) && grab_until(term_char, out group)) { error("No ending bracket."); return false; }
            if !add_group_matcher(group) { return false; }
        }
        else if 'K' == c_next {
            cur_state.add(create_matcher("global_group_reset", ""));
        }
        else if 'A' == c_next { cur_state.add(create_matcher("named_string_start", "")); }
        else if 'b' == c_next { cur_state.add(create_matcher("word_boundary_matcher_logic", "false")); }
        else if 'B' == c_next { cur_state.add(create_matcher("word_boundary_matcher_logic", "true")); }
        else if 'd' == c_next { cur_state.add(create_matcher("named_class_digits", "")); }
        else if 'D' == c_next { cur_state.add(create_matcher("named_class_not_digits", "")); }
        else if 'h' == c_next { cur_state.add(create_matcher("named_class_hor_space", "")); }
        else if 'H' == c_next { cur_state.add(create_matcher("named_class_not_hor_space", "")); }
        else if 'N' == c_next { cur_state.add(create_matcher("named_class_no_new_line", "")); }
        else if 's' == c_next { cur_state.add(create_matcher("named_class_space", "")); }
        else if 'S' == c_next { cur_state.add(create_matcher("named_class_not_space", "")); }
        else if 'v' == c_next { cur_state.add(create_matcher("named_class_ver_space", "")); }
        else if 'V' == c_next { cur_state.add(create_matcher("named_class_not_ver_space", "")); }
        else if 'w' == c_next { cur_state.add(create_matcher("named_class_word", "")); }
        else if 'W' == c_next { cur_state.add(create_matcher("named_class_not_word", "")); }
        else if 'Z' == c_next { cur_state.add(create_matcher("named_string_end_or_before_new_line_at_end", "")); }
        else if 'z' == c_next { cur_state.add(create_matcher("named_string_end", "")); }
        else {
            error("Unknown escape.");
            return false;
        }

        return true;
    }

    is_group: (inout this, c: char) -> bool = {
        if c != '(' { return false; }

        has_id := true;
        has_pattern := true;
        group_name : std::string = "";
        modifier_change: std::string = "::cpp2::regex::match_modifiers_no_change";

        c_next : char = '\0';
        // Skip the '('
        if !next(out c_next) { error("Group without closing bracket."); return false;}
        if c_next == '?' {
            // Special group
            if !next(out c_next) { error("Missing character after group opening."); return false; }

            if c_next == '<' {
                // named group
                if !next(out c_next) /* skip '<' */ { error("Missing ending bracket for named group."); return false; }
                if !grab_until('>', out group_name) { error("Missing ending bracket for named group."); return false; }
                if !next(out c_next) { error("Group without closing bracket."); return false;}
            }
            else {
                // Simple modifier
                has_id = false;
                change_str : std::string = "";
                if !grab_until_one_of("):", out change_str) { error("Missing ending bracket for group."); return false; }
                if !parse_modifiers(change_str, out modifier_change) {
                     return false;
                }

                if ')' == current() {
                    has_pattern = false;
                }
                else {
                    if !next(out c_next) /* skip ':' */ { error("Missing ending bracket for group."); return false; }
                }
            }
        }

        if has_pattern {
            // regular group

            group_number := -1;
            if has_id {
                group_number = next_group_id;
                next_group_id += 1;
            }

            old_state: _ = new_state();
            parse_until(')');
            inner:= create_matcher_from_state();
            restore_state(old_state);

            start_matcher := create_matcher("group_matcher_start_logic", "(group_number)$, (modifier_change)$, \"(group_name)$\"");
            if 0 != group_name.size() {
                if !named_groups.contains(group_name) { // Redefinition of group name is not an error. The left most one is retained.
                    named_groups[group_name] = group_number;
                }
            }
            end_matcher := create_matcher("group_matcher_end_logic", "(group_number)$");

            v: std::vector<std::string> = (start_matcher, inner, end_matcher);
            cur_state.add(create_matcher_from_list(v));
        }
        else {
            // Only a modifier
            cur_state.add(create_matcher("modifier_matcher_logic", "(modifier_change)$"));
        }

        return true;
    }

    is_handle_special: (inout this, c: char) -> bool = {
        if c == '\'' {
            cur_state.add(create_matcher("char_matcher_logic", "'\\(c)$', '\\(c)$', '\\(c)$'"));
            return true;
        }

        return false;
    }

    is_range: (inout this, c: char) -> bool = {

        to_int := :(str) -> int = {
            // TODO: Add exception handling.
            // try {
                return std::stoi(str);
            // } catch (_) {
            //     error("Could not convert range argument '(inner)$' to int.");
            // }
            // return 0;
        };

        if c != '{' { return false; }
        if cur_state.empty() { error("'{' without previous element.");  return false; }
        if !skip() { error("End of regex before closing '}'."); return false; }

        inner: std::string = "";
        if !grab_until('}', out inner) { error("Missing closing bracket."); return false; }

        inner = trim_copy(inner);
        if inner.empty() { error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'"); return false; }

        greedy := true;
        possessive := false;
        if peek() == '?' {
            greedy = false;
            pos += 1;
        }
        else if peek() == '+' {
            possessive = true;
            pos += 1;
        }

        min_count: std::string = "-1";
        min_count_number: int  = 0;
        max_count: std::string = "-1";
        max_count_number: int  = std::numeric_limits<int>::max();

        sep: size_t = inner.find(",");
        if sep == std::string::npos {
            min_count = inner;
            max_count = inner;
            min_count_number = to_int(inner);
            max_count_number = min_count_number;
        }
        else {
            inner_first: std::string = trim_copy(inner.substr(0, sep));
            inner_last: std::string = trim_copy(inner.substr(sep + 1));

            if (inner_first.empty() && inner_last.empty()) {
                error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'");
                return false;
            }

            if !inner_first.empty() {
                min_count = inner_first;
                min_count_number = to_int(inner_first);
            }
            if !inner_last.empty() {
                max_count = inner_last;
                max_count_number = to_int(inner_last);
            }
        }

        if !(0 <= min_count_number <= max_count_number) {
            error("Min and max values in range are wrong it should hold 0 <= min <= max. Have 0 <= (min_count_number)$ <= (max_count_number)$");
            return false;
        }

        cur_state.wrap_last( :(inner) -> _ == create_matcher("range_matcher_logic", "(inner)$, (min_count$)$, (max_count$)$, (greedy)$, (possessive)$"));

        return true;
    }

    is_special_range: (inout this, c: char) -> bool = {
        min_range: std::string = "0";
        max_range: std::string = "-1";
        if c == '*' {
            min_range = "0";
        }
        else if c == '+' {
            min_range = "1";
        }
        else if c == '?' {
            min_range = "0";
            max_range = "1";
        }
        else {
            return false;
        }

        greedy := true;
        possessive := false;
        if peek() == '?' {
            greedy = false;
            pos += 1;
        }
        else if peek() == '+' {
            possessive = true;
            pos += 1;
        }

        if cur_state.empty() {
            error("'(c)$' without previous element.");
            return false;
        }

        cur_state.wrap_last(:(inner) -> _ == create_matcher("special_range_matcher_logic", "(inner)$, (min_range$)$, (max_range$)$, (greedy)$, (possessive)$, '(c$)$'"));
        return true;
    }

    parse_until:(inout this, term: char) = {
        while pos != regex.size() next pos += 1 {
            c: char = regex[pos];

            if c == term { return; }

            if !has_error && is_alternative(c) { continue; }
            if !has_error && is_any(c) { continue; }
            if !has_error && is_class(c) { continue; }
            if !has_error && is_escape(c) { continue; }
            if !has_error && is_anchor(c) { continue; }
            if !has_error && is_group(c) { continue; }
            if !has_error && is_handle_special(c) { continue; }
            if !has_error && is_range(c) { continue; }
            if !has_error && is_special_range(c) { continue; }

            if has_error { return; }

            // No special char, push a character match
            cur_state.add(create_matcher("char_matcher_logic", "'(c)$', '(safe_tolower(c))$', '(safe_toupper(c))$'"));
        }
    }

    parse_modifier: (inout this) -> std::string = {
        r: std::string = "0";
        sep: std::string = " | ";

        add := :(name, inout r) = {
            r += "(sep$)$(name)$";
        };

        mod_pos := 0;
        while mod_pos != modifier.size() next mod_pos += 1 {
            c: char = modifier[mod_pos];

            if      c == 'i' { add("::cpp2::regex::expression_flags::case_insensitive", r); }
            else if c == 'm' { add("::cpp2::regex::expression_flags::multiple_lines", r); }
            else if c == 's' { add("::cpp2::regex::expression_flags::single_line", r); }
            else { error("Unknown modifier: '(c)$'"); }
        }

        return r;
    }

    parse:(inout this) -> std::string = {
        parse_until('\0');

        if has_error { return "Error"; }

        mod   := parse_modifier();
        named_groups_arg := create_named_groups_arg();
        inner := create_matcher_from_state();
        start := create_matcher("group_matcher_start_logic", "0, ::cpp2::regex::match_modifiers_no_change, \"\"");
        end   := create_matcher("group_matcher_end_logic", "0");
        list  := create_matcher("matcher_list", "(start)$, (inner)$, (end)$");
        return   create_matcher("regular_expression", "(mod)$, (next_group_id)$, (alternatives_count)$, (named_groups_arg)$, (list)$");
    }

}

generate_template: <Err> (regex: std::string_view, modifier: std::string_view, err: Err) -> std::string = {
    parser: regex_parser<Err> = (regex, modifier, err);
    r := parser.parse();
    _ = parser;
    return r;
}

}
}
