
//  Copyright (c) Herb Sutter
//  SPDX-License-Identifier: CC-BY-NC-ND-4.0

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#include <map>
#include <set>

cpp2: namespace = {

regex: namespace = {

greedy_alternative : bool == false;

bview: <CharT> type == std::basic_string_view<CharT>;
bstring: <CharT> type == std::basic_string<CharT>;

//-----------------------------------------------------------------------
//
//  Helper structures for the expression matching.
//
//-----------------------------------------------------------------------
//

expression_flags: type = {
    case_insensitive : int            ==  1;  // mod: i
    multiple_lines: int               ==  2;  // mod: m
    single_line: int                  ==  4;  // mod: s
    no_group_captures: int            ==  8;  // mod: n
    perl_code_syntax: int             == 16;  // mod: x
    perl_code_syntax_in_classes: int  == 32;  // mod: xx
}

// TODO: @enum as template parameter yields two error:
//     error: type 'range_flags' of non-type template parameter is not a structural type
//     error: non-type template parameter has incomplete type 'range_flags'
range_flags: type = {
    not_greedy: int == 1;
    greedy:     int == 2;
    possessive: int == 3;
}

match_group: @struct <Iter> type = {
    start: Iter = ();
    end: Iter = ();

    matched: bool = false;
}

match_return: @struct <Iter> type = {
    matched: bool = false;
    pos: Iter = ();
}

match_context: <CharT, Iter, max_groups: int, max_alternatives: int> type =
{
    public begin: Iter;
    public end: Iter;

    private groups: std::array<match_group<Iter>, max_groups> = ();
    private alternatives_pos: std::array<Iter, max_alternatives> = ();

    operator=: (out this, begin_: Iter, end_: Iter) = {
        begin = begin_;
        end = end_;
    }

    operator=: (out this, that) = {}

    // Getter and setter for groups
    //
    get_group: (in this, group) groups[group];

    get_group_string: (in this, group) -> std::string = {
        if group >= max_groups || !groups[group].matched {
            return "";
        }
        return std::string(groups[group].start, groups[group].end);
    }
    get_group_start:  (in this, group) -> int = {
        if group >= max_groups || !groups[group].matched {
            return 0;
        }
        return std::distance(begin, groups[group].start);
    }
    get_group_end:    (in this, group) -> int = {
        if group >= max_groups || !groups[group].matched {
            return 0;
        }
        return std::distance(begin, groups[group].end);
    }

    set_group_end: (inout this, group, pos) = {
        groups[group].end = pos;
        groups[group].matched = true;
    }

    set_group_invalid: (inout this, group) = {
        groups[group].matched = false;
    }

    set_group_start: (inout this, group, pos) = {
        groups[group].start = pos;
    }

    size: (in this) max_groups;

    // Getter and setter for alternatives

    get_alternative_pos: (in this, alternative) alternatives_pos[alternative];

    set_alternative_pos: (inout this, alternative, pos) = {
        alternatives_pos[alternative] = pos;
    }

    // Misc functions
    //
    print_ranges: (in this) -> bstring<CharT> = {
        r: bstring<CharT> = "";
        for groups do (cur) {
            if cur.matched {
                r += "((std::distance(begin, cur.start))$,(std::distance(begin, cur.end))$)";
            }
            else {
                r += "(?,?)";
            }
        }

        return r;
    }

    fail: (in this)            match_return(false, end);
    pass: (in this, cur: Iter) match_return(true, cur);

}

// Flag change for matching modifiers. Creates a new flag for match_modifiers.
// See expression_flags for possible flags.
//
match_modifiers_state_change: <has_change_: bool, reset_: bool, add_: int, remove_: int, str: fixed_string> type = {

    reset: bool == reset_;
    add: int == add_;
    remove: int == remove_;
    has_change: bool == has_change_;

    combine_inner: (old_flags: int) -> _ == {
        new_flags := old_flags;
        if reset {
            new_flags = 0;
        }
        new_flags = new_flags | add;
        new_flags = new_flags & (remove~);

        return new_flags;
    }

    to_string: () str.data();
}

match_modifiers_no_change : type == match_modifiers_state_change<false, false, 0, 0, "">;

// Current modifiers for the regular expression.
// See expression_flags for possible flags.
//
match_modifiers: @struct <flags_: int, Inner> type = {

    flags : int == flags_;

    // Push/pop management

    push: <Change>   (_ : Change) match_modifiers<Change::combine_inner(flags), match_modifiers<flags, Inner>>();
    pop:             ()           Inner();
    replace: <Change>(_ : Change) match_modifiers<Change::combine_inner(flags), Inner>();

    // Flag management
    //

    has_flag: (this, f: int) -> bool = {
        return  0 != (f & flags);
    }
}

//  Represents the remainder of the regular expression.
//
//  A matcher can ask this remainder if it would match. If yes a full match of the regular expression is found.
//  Otherwise the matcher can try a different alternative.
//
matcher_list: <CharT, List...> type = {
    match: (cur, inout ctx, modifiers, end_func) match_select<List...>(cur, ctx, modifiers, end_func);

    match: <OtherList...> (cur, inout ctx, modifiers, end_func, _: matcher_list<CharT, OtherList...>)
        match_select<List..., OtherList...>(cur, ctx, modifiers, end_func);

    private match_select: <First, Other...> (cur, inout ctx, modifiers, end_func)
        First::match(cur, ctx, modifiers, end_func, matcher_list<CharT, Other...>());
    private match_select: (cur, inout ctx, modifiers, end_func) end_func(cur, ctx, modifiers);

    reset_ranges: ( inout ctx) = (List::reset_ranges(ctx), ...);
    to_string: () (bstring<CharT>() + ... + List::to_string());

    prepend: <Pre> (_ : Pre) matcher_list<CharT, Pre, List...>();
}

no_tail: <CharT> type == matcher_list<CharT>;
true_end_func: @struct type = {
    operator(): (in this, cur, inout ctx, _) ctx.pass(cur);
}

//-----------------------------------------------------------------------
//
//  Character classes for regular expressions.
//
//-----------------------------------------------------------------------
//

// Class syntax: <any character> Example: a
//
single_class_entry: <CharT, C: CharT> type =
{
    includes: (c: CharT) c == C;
    to_string: ()        bstring<CharT>(1, C);
}

// Class syntax: - Example: a-c
//
range_class_entry: <CharT, Start: CharT, End: CharT> type =
{
    includes: (c: CharT) Start <= c <= End;
    to_string:        () "(Start)$-(End)$";
}

// Helper for combining two character classes
//
combined_class_entry: <CharT, List ...> type = {
    includes: (c: CharT) (false || ... || List::includes(c));
    to_string: ()        (bstring<CharT>() + ... + List::to_string());
}

// Class syntax: <list of characters>  Example: abcd
//
list_class_entry: <CharT, List ... : CharT> type = {
    includes: (c: CharT) (false || ... || (List == c));
    to_string: ()        (bstring<CharT>() + ... + List);
}

// Class syntax: [:<class name:]  Example: [:alnum:]
//
named_class_entry: <CharT, Name: fixed_string, Inner> type = {
    includes: (c: CharT) Inner::includes(c);
    to_string: ()        "[:(Name.data())$:]";
}

negated_class_entry: <CharT, Inner> type = {
    this: Inner = ();
    includes: (c: CharT) !Inner::includes(c);
}

// Short class syntax: \<character>  Example: \w
//
shorthand_class_entry: <CharT, Name: fixed_string, Inner> type = {
    includes: (c: CharT) Inner::includes(c);
    to_string: ()        Name.str();
}


// Named basic character classes
//
digits_class  : <CharT> type == named_class_entry<CharT, "digits", range_class_entry<CharT, '0', '9'>>;
lower_class   : <CharT> type == named_class_entry<CharT, "lower", range_class_entry<CharT, 'a', 'z'>>;
upper_class   : <CharT> type == named_class_entry<CharT, "upper", range_class_entry<CharT, 'A', 'Z'>>;

// Named other classes
//
alnum_class     : <CharT> type == named_class_entry<CharT, "alnum", combined_class_entry<CharT, lower_class<CharT>, upper_class<CharT>, digits_class<CharT>>>;
alpha_class     : <CharT> type == named_class_entry<CharT, "alpha", combined_class_entry<CharT, lower_class<CharT>, upper_class<CharT>>>;
ascii_class     : <CharT> type == named_class_entry<CharT, "ascii", range_class_entry<CharT, '\x00', '\x7F'>>;
blank_class     : <CharT> type == named_class_entry<CharT, "blank", list_class_entry<CharT, ' ', '\t'>>;
cntrl_class     : <CharT> type == named_class_entry<CharT, "cntrl", combined_class_entry<CharT, range_class_entry<CharT, '\x00', '\x1F'>, single_class_entry<CharT, '\x7F'>>>;
graph_class     : <CharT> type == named_class_entry<CharT, "graph", range_class_entry<CharT, '\x21', '\x7E'>>;
hor_space_class : <CharT> type == named_class_entry<CharT, "hspace", list_class_entry<CharT, '\t', ' '>>;
print_class     : <CharT> type == named_class_entry<CharT, "print", range_class_entry<CharT, '\x20', '\x7E'>>;
punct_class     : <CharT> type == named_class_entry<CharT, "punct", list_class_entry<CharT, '[','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/',':',';','<','=','>','?','@','[','\\',']','^','_','`','{','|','}','~',']'>>;
space_class     : <CharT> type == named_class_entry<CharT, "space", list_class_entry<CharT, ' ', '\t', '\r', '\n', '\v', '\f'>>;
ver_space_class : <CharT> type == named_class_entry<CharT, "vspace", list_class_entry<CharT, '\n', '\v', '\f', '\r'>>;
word_class      : <CharT> type == named_class_entry<CharT, "word", combined_class_entry<CharT, alnum_class<CharT>, single_class_entry<CharT, '_'>>>;
xdigit_class    : <CharT> type == named_class_entry<CharT, "xdigit", combined_class_entry<CharT, range_class_entry<CharT, 'A', 'F'>, range_class_entry<CharT, 'a', 'f'>, digits_class<CharT>>>;

// Shorthand class entries
//
short_digits_class     : <CharT> type == shorthand_class_entry<CharT, "\\d", digits_class<CharT>>;
short_hor_space_class  : <CharT> type == shorthand_class_entry<CharT, "\\h", hor_space_class<CharT>>;
short_space_class      : <CharT> type == shorthand_class_entry<CharT, "\\s", space_class<CharT>>;
short_vert_space_class : <CharT> type == shorthand_class_entry<CharT, "\\v", ver_space_class<CharT>>;
short_word_class       : <CharT> type == shorthand_class_entry<CharT, "\\w", word_class<CharT>>;


short_not_digits_class     : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\D", digits_class<CharT>>>;
short_not_hor_space_class  : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\H", hor_space_class<CharT>>>;
short_not_space_class      : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\S", space_class<CharT>>>;
short_not_vert_space_class : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\V", ver_space_class<CharT>>>;
short_not_word_class       : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\W", word_class<CharT>>>;

//-----------------------------------------------------------------------
//
//  Helper matchers for regular expressions.
//
//-----------------------------------------------------------------------
//

// Regex syntax: none Example: -
//
empty_matcher_logic: <CharT> type = {
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) Other::match(cur, ctx, modifiers, end_func);
    reset_ranges:  (_) = {}
    to_string:     ()  bstring<CharT>();
}


// Helper for greedy alternatives
//
extract_position_helper: <CharT, alternative: size_t> type = {
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        r := Other::match(cur, ctx, modifiers, end_func);
        if r.matched {
            ctx.set_alternative_pos(alternative, cur);
        }
        return r;
    }

    reset_ranges: (_) = {}
    to_string:    () bstring<CharT>();
}

// Helper for standard matchers with special syntax
//
//
special_syntax_wrapper: <CharT, syntax: fixed_string, base> type = {
    this : base = ();
    to_string:    () syntax.str();
}

//-----------------------------------------------------------------------
//
// Matchers and generators for regular expressions.
//
//-----------------------------------------------------------------------
//


no_reset: @struct type = {
    operator(): (this, inout _:) = {}
}

on_return: <Func> type = {

    func: Func;

    operator=: (out this, f: Func) = {
        func = f;
    }

    operator=: (move this) = {
        func();
    }
}

make_on_return: <Func> (func: Func) on_return<Func>(func);

regex_token: @polymorphic_base type = {

    public string_rep: std::string;

    operator=:(out this, str: std::string) = {
        string_rep = str;
    }

    operator=:(out this) = {
        string_rep = "";
    }

    //parse: (inout ctx: parse_context) -> token_ptr;
    generate_code: (virtual this, inout _: generation_context);

    add_groups: (virtual this, inout _: std::set<int>);
    to_string: (this) -> std::string         = { return string_rep; }
    set_string: (inout this, s: std::string) = { string_rep = s; }
}

token_ptr : type == std::shared_ptr<regex_token>;
token_vec: type == std::vector<token_ptr>;

// State of the expression modifiers.
//
parse_context_modifier_state: @struct type = {
    group_captures_have_numbers : bool = true;
    perl_code_syntax:             bool = false;
    perl_code_syntax_in_classes:  bool = false;
}

// State of the current group. See '(<pattern>)'
parse_context_group_state: @struct type = {

    // Current list of matchers
    cur_match_list: token_vec = ();

    // List of alternate matcher lists. E.g. ab|cd|xy
    alternate_match_lists: token_vec = ();

    modifiers : parse_context_modifier_state = ();

    next_alternative: (inout this) = {
        new_list: token_vec = ();
        std::swap(new_list, cur_match_list);
        _ = alternate_match_lists.insert(alternate_match_lists.end(), shared.new<regex_token_list>(new_list));
    }

    swap: (inout this, inout t: parse_context_group_state) = {
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
        std::swap(modifiers, t.modifiers);
    }

    get_tokens: (inout this) -> token_ptr = {
        if alternate_match_lists.empty() {
            return shared.new<regex_token_list>(cur_match_list);
        }
        else {
            next_alternative();
            return shared.new<alternative_token_gen>(alternate_match_lists);
        }
    }

    add: (inout this, token: token_ptr) = cur_match_list.push_back(token);

    empty: (this) -> bool = cur_match_list.empty();
}

// State for the branch reset. Takes care of the group numbering. See '(|<pattern>)'.
parse_context_branch_reset_state: @struct type = {
    is_active : bool = false;
    cur_group : int  = 1; // Global capture group.
    max_group : int  = 1;
    from      : int  = 1;

    next: (inout this) -> int = {
        g := cur_group;
        cur_group += 1;
        max_group = max(max_group, cur_group);

        return g;
    }

    set_next: (inout this, g: int) = {
        cur_group = g;
        max_group = max(max_group, g);
    }

    next_alternative: (inout this) = {
        if is_active {
            cur_group = from;
        }
    }

    set_active_reset: (inout this, restart: int) = {
        is_active = true;
        cur_group = restart;
        from      = restart;
        max_group = restart;
    }
}

parse_context: type = {
    regex: std::string_view;

    pos: size_t = 0;

    public error_text: std::string = "";

    cur_group_state:        parse_context_group_state = ();
    cur_branch_reset_state: parse_context_branch_reset_state = ();
    named_groups :          std::map<std::string, int> = ();

    operator=:(out this, r: std::string_view, modifiers: parse_context_modifier_state) = {
        regex = r;
        set_modifiers(modifiers);
    }

    // State management functions
    //

    start_group: (inout this) -> parse_context_group_state = {
        old_state: parse_context_group_state = ();
        old_state.swap(cur_group_state);

        return old_state;
    }

    end_group: (inout this, old_state: parse_context_group_state) -> token_ptr = {
        inner := cur_group_state.get_tokens();
        cur_group_state = old_state;
        return inner;
    }

    get_modifiers: (this) -> parse_context_modifier_state = {
        return cur_group_state.modifiers;
    }

    set_modifiers: (inout this, mod: parse_context_modifier_state) = {
        cur_group_state.modifiers = mod;
    }

    // Branch reset management functions
    //

    branch_reset_new_state: (inout this) -> parse_context_branch_reset_state = {
        old_state: parse_context_branch_reset_state = ();
        std::swap(old_state, cur_branch_reset_state);

        cur_branch_reset_state.set_active_reset(old_state.cur_group);
        return old_state;
    }

    branch_reset_restore_state: (inout this, old_state: parse_context_branch_reset_state) = {
        max_group := cur_branch_reset_state.max_group;
        cur_branch_reset_state = old_state;
        cur_branch_reset_state.set_next(max_group);
    }

    next_alternative: (inout this) = {
        cur_group_state.next_alternative();
        cur_branch_reset_state.next_alternative();
    }

    // Position management functions
    //

    get_pos: (this) pos;

    get_range: (this, start: int, end: int) std::string(regex.substr(start, end - start + 1));

    add_token: (inout this, token: token_ptr) = {
        cur_group_state.add(token);
    }

    has_token: (this) -> bool = {
        return !cur_group_state.empty();
    }

    pop_token: (inout this) -> token_ptr = {
        r : token_ptr = nullptr;
        if has_token() {
            r = cur_group_state.cur_match_list.back();
            cur_group_state.cur_match_list.pop_back();
        }

        return r;
    }

    get_tokens: (inout this) -> token_ptr = {
        return cur_group_state.get_tokens();
    }

    // Group management
    get_cur_group: (this) -> int = {
        return cur_branch_reset_state.cur_group;
    }

    next_group: (inout this) -> int = {
        return cur_branch_reset_state.next();
    }

    set_named_group: (inout this, name: std::string, id: int) = {
        if !named_groups.contains(name) { // Redefinition of group name is not an error. The left most one is retained.
            named_groups[name] = id;
        }
    }

    get_named_group: (this, name: std::string) -> int = {
        iter := named_groups.find(name);
        if iter == named_groups.end() {
             return -1;
        }
        else {
            return iter*.second;
        }
    }

    current: (this) -> char = { return regex[pos]; }

    private next_impl: (inout this, in_class: bool, no_skip: bool) -> bool = {
        pos = get_next_position(in_class, no_skip);
        if pos != regex.size() {
            return true;
        }
        else {
            return false;
        }
    }

    next: (inout this)          next_impl(false, false);
    next_in_class: (inout this) next_impl(true, false);
    next_no_skip: (inout this)  next_impl(false, true);

    next_n: (inout this, n: int) -> bool = {
        r := true;
        cur := 0;
        while r && cur < n next (r = next()) {
            cur += 1;
        }
        return r;
    }

    has_next: (this) -> bool = { return pos < regex.size(); }

    valid: (this) -> bool = { return has_next() && error_text.empty(); }

    error: (inout this, err: std::string) -> token_ptr = {
        error_text = err;
        return nullptr;
    }

    join: (list, func) -> std::string = {
        r: std::string = "";

        separator: std::string = "";
        for list do (cur) {
            r += separator + func(cur);
            separator = ", ";
        }

        return r;
    }

    join: (list: std::vector<std::string>) join(list, :(arg) -> _ == arg); // Todo: Shorthand syntax for const lambda

    private get_next_position: (in this, in_class: bool, no_skip: bool) -> size_t = {
        perl_syntax := false;
        if !no_skip {
            if in_class {
                perl_syntax = cur_group_state.modifiers.perl_code_syntax && cur_group_state.modifiers.perl_code_syntax_in_classes;
            }
            else {
                perl_syntax = cur_group_state.modifiers.perl_code_syntax;
            }
        }
        cur := pos + 1;
        if perl_syntax {
            while cur < regex.size() next (cur += 1) {
                n: = regex[cur];

                if space_class<char>::includes(n) {
                    continue;
                }
                else if !in_class && '#' == n {
                    cur = regex.find("\n", cur);
                    if std::string::npos == cur {
                        // No new line, comment runs until the end of the pattern
                        cur = regex.size();
                    }
                }
                else { // None space none comment char
                    break;
                }
            }
        }

        // Check for end of file.
        if cur > regex.size() {
            cur = regex.size();
        }
        return cur;
    }


    private grab_until_impl: (inout this, in e: std::string, out r: std::string, any: bool) -> bool = {
        start := pos;
        end:= pos;
        if any {
            end = regex.find_first_of(e, pos);
        }
        else {
            end = regex.find(e, pos);
        }

        if end != std::string_view::npos {
            r = regex.substr(start, end - pos);
            pos = end;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_until: (inout this, in e: std::string, out r: std::string)        grab_until_impl(e, out r, false);
    grab_until: (inout this, in e: char, out r: std::string)               grab_until_impl(std::string(1, e), out r, false);
    grab_until_one_of: (inout this, in e: std::string, out r: std::string) grab_until_impl(e, out r, true);

    grab_n: (inout this, in n: int, out r: std::string) -> bool = {
        if pos + n <= regex.size() {
            r = regex.substr(pos, n);
            pos += n - 1;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_number: (inout this) -> std::string = {
        start := pos;
        start_search := pos;
        if regex[start_search] == '-' {
            start_search += 1;
        }
        end := regex.find_first_not_of("1234567890", start_search);

        r : std::string;
        if end != std::string::npos {
            r = regex.substr(start, end - start);
            pos = end - 1;
        }
        else {
            r = regex.substr(start);
            pos = regex.size() - 1;
        }
        return r;
    }

    private peek_impl: (in this, in_class: bool) -> char = {
        next_pos := get_next_position(in_class, false);
        if next_pos < regex.size() {
            return regex[next_pos];
        }
        else {
            return '\0';
        }
    }

    peek: (in this)          peek_impl(false);
    peek_in_class: (in this) peek_impl(true);

    parser_group_modifiers: (inout this, change_str: std::string, out modifier_change: std::string,
                      inout parser_modifiers: parse_context_modifier_state) -> bool = {
        is_negative := false;
        is_reset    := false;

        add    := 0;
        remove := 0;

        apply := :(flag: int) = {
            if is_negative&$* {
                remove&$* |= flag;
            }
            else {
                add&$* |= flag;
            }
        };

        iter := change_str.begin();
        while iter != change_str.end() next (iter++) {
            cur := iter*;
            if cur == '^' {
                is_reset = true;
            }
            else if cur == '-' {
                if is_reset { _= error("No negative modifier allowed."); return false; }
                is_negative = true;
            }
            else if cur == 'i' { apply(expression_flags::case_insensitive); }
            else if cur == 'm' { apply(expression_flags::multiple_lines); }
            else if cur == 's' { apply(expression_flags::single_line); }
            else if cur == 'n' {
                apply(expression_flags::no_group_captures);
                parser_modifiers.group_captures_have_numbers = is_negative;
            }
            else if cur == 'x' {
                if (iter + 1) == change_str.end() || (iter + 1)* != 'x' {
                    // x modifier
                    apply(expression_flags::perl_code_syntax);
                    parser_modifiers.perl_code_syntax = !is_negative;

                    // Just x unsets xx and remove x also removes xx
                    remove |= expression_flags::perl_code_syntax_in_classes;
                    parser_modifiers.perl_code_syntax_in_classes = false;
                }
                else { // xx modifier
                    // xx also sets or unsets x
                    apply(expression_flags::perl_code_syntax);
                    parser_modifiers.perl_code_syntax = !is_negative;

                    apply(expression_flags::perl_code_syntax_in_classes);
                    parser_modifiers.perl_code_syntax_in_classes = !is_negative;

                    iter++; // Skip the second x
                }
            }
            else {
                _= error("Unknown modifier: (cur)$"); return false;
            }
        }

        modifier_change = "::cpp2::regex::match_modifiers_state_change<true, (is_reset)$, (add)$, (remove)$, \"(change_str)$\">";

        return true;
    }

    parse_until:(inout this, term: char) -> bool = {
        cur_token: token_ptr = ();

        while valid() next _ = next() {
            if term == current() { break; }

            cur_token = nullptr;

            if !cur_token && valid() { cur_token = alternative_token::parse(this); }
            if !cur_token && valid() { cur_token = any_token::parse(this); }
            if !cur_token && valid() { cur_token = class_token::parse(this); }
            if !cur_token && valid() { cur_token = escape_token_parse(this); }
            if !cur_token && valid() { cur_token = global_group_reset_token_parse(this); }
            if !cur_token && valid() { cur_token = group_ref_token::parse(this); }
            if !cur_token && valid() { cur_token = group_token::parse(this); }
            if !cur_token && valid() { cur_token = hexadecimal_token_parse(this); }
            if !cur_token && valid() { cur_token = line_end_token_parse(this); }
            if !cur_token && valid() { cur_token = line_start_token_parse(this); }
            if !cur_token && valid() { cur_token = named_class_token_parse(this); }
            if !cur_token && valid() { cur_token = octal_token_parse(this); }
            if !cur_token && valid() { cur_token = range_token::parse(this); }
            if !cur_token && valid() { cur_token = special_range_token::parse(this); }
            if !cur_token && valid() { cur_token = word_boundary_token_parse(this); }

            // Everything else is matched as it is.
            if !cur_token && valid() { cur_token = char_token::parse(this); }

            if cur_token && valid() {
                add_token(cur_token);
            } else {
                return false;
            }
        }

        return true;
    }

    parse: (inout this) parse_until('\0');


}

generation_function_context: @struct type = {
    code: std::string = "";
    tabs: std::string = "";

    add_tabs: (inout this, c: int) = {
        i: int = 0;
        while i < c next i += 1 {
            tabs += "  ";
        }
    }

    remove_tabs: (inout this, c: int) = {
        tabs = tabs.substr(0, c * 2);
    }
}

generation_context: type = {

    gen_stack: std::vector<generation_function_context> = (1);

    new_state : bool = true;
    matcher_func: int         = 0;
    reset_func:   int         = 0;
    temp_name:    int         = 0;
    entry_func:   std::string = "";

    match_parameters: (this) -> std::string = { return "r.pos, ctx, modifiers"; }

    add: (inout this, s: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$(s)$\n";
    }

    add_check: (inout this, check: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$if !cpp2::regex::(check)$ { r = ctx.fail(); return r; }\n";
    }

    add_statefull: (inout this, next_func: std::string, c: std::string) = {
        end_func_statefull(c);

        name := next_func.substr(0, next_func.ssize() - 2);
        start_func_named(name);
    }

    run: (inout this, token: token_ptr) -> std::string = {
        entry_func = generate_func(token);

        return get_base()*.code;
    }

    generate_func: (inout this, token: token_ptr) -> std::string = {
        name := start_func();
        token*.generate_code(this);
        end_func();

        return name;
    }

    generate_reset: (inout this, groups: std::set<int>) -> std::string = {
        if groups.empty() {
            return "cpp2::regex::no_reset()";
        }

        name := gen_reset_func_name();
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): (this, inout ctx) = {\n";
        for groups do (g) {
            cur*.code += "(cur*.tabs)$  ctx.set_group_invalid((g)$);\n";
        }
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();

        return name + "()";
    }


    get_current: (inout this) -> *generation_function_context = {
        return gen_stack.back()&;
    }

    get_base: (inout this) -> *generation_function_context = {
        return gen_stack[0]&;
    }

    next_func_name: (inout this) -> std::string = {
        return gen_func_name() + "()";
    }

    protected start_func_named: (inout this, name: std::string) = {
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): (this, cur, inout ctx, modifiers, other) -> _ = {\n";
        cur*.code += "(cur*.tabs)$    r := ctx.pass(cur);\n";
        cur*.add_tabs(2);
    }

    start_func: (inout this) -> std::string = {
        name := gen_func_name();
        start_func_named(name);
        return name + "()";
    }

    end_func_statefull: (inout this, s: std::string) = {
        cur := get_current();
        cur*.remove_tabs(2);
        cur*.code += "\n";
        cur*.code += "(cur*.tabs)$    r = (s)$;\n";
        cur*.code += "(cur*.tabs)$    return r;\n";
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();
    }

    end_func: (inout this) = {
        end_func_statefull("other(r.pos, ctx, modifiers)");
    }

    get_entry_func: (this) -> std::string = {
        return entry_func;
    }

    protected gen_func_name: (inout this) -> std::string = {
        cur_id : = matcher_func;
        matcher_func += 1;
        return "func_(cur_id)$";
    }

    protected gen_reset_func_name: (inout this) -> std::string = {
        cur_id : = reset_func;
        reset_func += 1;
        return "reset_(cur_id)$";
    }

    gen_temp: (inout this) -> std::string = {
        cur_id := temp_name;
        temp_name += 1;
        return "tmp_(cur_id)$";
    }

    new_context: (inout this) -> *generation_function_context = {
        gen_stack.push_back(generation_function_context());
        cur := get_current();
        cur*.tabs = "    ";

        return cur;
    }

    finish_context: (inout this) = {
        cur := get_current();
        base := get_base();
        base*.code += cur*.code;

        gen_stack.pop_back();
    }
}

regex_token_list: @polymorphic_base type = {
    this: regex_token;

    public tokens: token_vec;

    operator=:(out this, t: token_vec) = {
        regex_token = (gen_string(t));
        tokens = t;
    }

    generate_code: (virtual this, inout ctx: generation_context) = {
        for tokens do (token) {
            token*.generate_code(ctx);
        }
    }

    add_groups: (virtual this, inout groups: std::set<int>) = {
        for tokens do (token) {
            token*.add_groups(groups);
        }
    }

    gen_string: (vec: token_vec) -> std::string = {
        r : std::string = "";
        for vec do (token) {
            r += token*.to_string();
        }
        return r;
    }
}


regex_token_base: @polymorphic_base type = {
    this: regex_token;

    operator=:(out this, str: std::string) = {
        regex_token = (str);
    }

    operator=:(out this) = {
        regex_token = ();
    }

    add_groups: (override this, inout _: std::set<int>) = {}
}

regex_token_check: @polymorphic_base type = {
    this: regex_token_base;

    check: std::string;

    operator=:(out this, str: std::string, check_: std::string) = {
        regex_token_base = (str);
        check = check_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx.add_check(check + "(" + ctx.match_parameters() + ")");
    }
}

regex_token_code: @polymorphic_base type = {
    this: regex_token_base;

    code: std::string;

    operator=:(out this, str: std::string, code_: std::string) = {
        regex_token_base = (str);
        code = code_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx.add(code);
    }
}


regex_token_empty: @polymorphic_base type = {
    this: regex_token_base;

    operator=:(out this, str: std::string) = {
        regex_token_base = (str);
    }

    generate_code: (override this, inout _: generation_context) = {
        // Nothing.
    }
}

//  Regex syntax: |  Example: ab|ba
//
//  Non greedy implementation. First alternative that matches is chosen.
//
alternative_token: @polymorphic_base type = {
    this: regex_token_base = ();

    operator=:(out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr = {
        if ctx.current() != '|' { return nullptr; }

        if !ctx.has_token() { return ctx.error("Alternative with no content."); }
        ctx.next_alternative();
        return shared.new<alternative_token>();
    }

    generate_code: (override this, inout _: generation_context) = {
        // No code gen here. alternative_token_gen is created in the parse_context
    }
}

alternative_token_gen: @polymorphic_base type = {
    this: regex_token;


    alternatives: token_vec;

    operator=: (out this, a: token_vec) = {
        regex_token = gen_string(a);
        alternatives = a;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        functions: std::string = "";

        for alternatives do (cur) {
            groups: std::set<int> = ();
            cur*.add_groups(groups);

            functions += ", " + ctx.generate_func(cur);
            functions += ", " + ctx.generate_reset(groups);
        }

        next_name := ctx.next_func_name();

        ctx.add_statefull(next_name, "cpp2::regex::alternative_token_matcher<char>::match((ctx.match_parameters())$, other, (next_name)$ (functions)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        for alternatives do (cur) {
            cur*.add_groups(groups);
        }
    }

    gen_string: (a: token_vec) -> std::string = {
        r: std::string = "";
        sep: std::string = "";

        for a do (cur) {
            r += sep + cur*.to_string();
            sep = "|";
        }

        return r;
    }
}

alternative_token_matcher: <CharT> type = {

    match: (cur, inout ctx, modifiers, end_func, tail, functions ...) -> _ = {
        return match_first(cur, ctx, modifiers, end_func, tail, functions...);
    }
    private match_first: <Other ...> (cur, inout ctx, modifiers, end_func, tail, cur_func, cur_reset, other ...: Other) -> _ = {
        inner_call := :(tail_cur, inout tail_ctx, tail_modifiers) -> _ == {
            return (tail)$(tail_cur, tail_ctx, tail_modifiers, (end_func)$);
        };
        r := cur_func(cur, ctx, modifiers, inner_call);
        if r.matched {
            return r;
        } else {
            cur_reset(ctx);

            if constexpr 0 != sizeof...(Other) {
                return match_first(cur, ctx, modifiers, end_func, tail, other...);
            } else {
                return ctx.fail();
            }
        }
    }
}

//  Regex syntax: .
//
any_token: @polymorphic_base type = {
    this: regex_token_base = (".");

    operator=:(out this) = {} // TODO: Base class constructor is ignored.

    parse: (inout ctx: parse_context) -> token_ptr = {
        if '.' != ctx.current() { return nullptr;}

        return shared.new<any_token>();
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx.add_check("any_token_matcher<char>((ctx.match_parameters())$)");
    }
}

any_token_matcher: <CharT> (inout cur, inout ctx, modifiers) -> bool = {
    if cur != ctx.end // Any char except the end
        && (modifiers.has_flag(expression_flags::single_line) || cur* != '\n') { // Do not match new lines in multi line mode.
        cur += 1;
        return true;
    }
    else {
        return false;
    }
}

char_token: @polymorphic_base type = {
    this: regex_token_base;

    token: char;

    operator=: (out this, t: char) = {
        regex_token_base = (std::string(1, t));
        token = t;
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        return shared.new<char_token>(ctx.current());
    }

    generate_code: (override this, inout ctx: generation_context) = {
        upper: = safe_toupper(token);
        lower: = safe_tolower(token);
        ctx.add_check("char_token_matcher<char, '(token)$', '(lower)$', '(upper)$'>((ctx.match_parameters())$)");
    }
}

char_token_matcher: <CharT, C: CharT, L: CharT, U: CharT> (inout cur, inout ctx, modifiers) -> bool = {
    if modifiers.has_flag(expression_flags::case_insensitive) {
        if cur != ctx.end && (cur* == L || cur* == U) {
            cur += 1;
            return true;
        }
        else {
            return false;
        }
    }
    else {
        if cur != ctx.end && cur* == C {
            cur += 1;
            return true;
        }
        else {
            return false;
        }
    }
}

// Regex syntax: [<character classes>]  Example: [abcx-y[:digits:]]
//
class_token: @polymorphic_base type = {
    this: regex_token_base = ();

    negate: bool;
    class_str: std::string;

    operator=: (out this, negate_: bool, class_str_: std::string, str: std::string) = {
        regex_token_base = str;
        negate = negate_;
        class_str = class_str_;
    }

    // TODO: Rework class generation: Generate check functions for classes.
    parse: (inout ctx: parse_context) -> token_ptr = {
        if ctx.current() != '[' { return nullptr; }

        start_pos := ctx.get_pos();

        supported_classes: std::vector<std::string> = ("alnum", "alpha", "ascii", "blank", "cntrl", "digits", "graph",
                                                       "lower", "print", "punct", "space", "upper", "word", "xdigit");

        classes: std::vector<std::string> = ();

        // First step: parse until the end bracket and push single chars, ranges or groups on the class stack.
        is_negate:= false;
        first:= true;
        range:= false;
        while ctx.next_in_class() & (ctx.current() != ']' || first) {
            if ctx.current() == '^' {
                is_negate = true;
                continue; // Skip rest of the loop. Also the first update.
            }
            if ctx.current() == '[' && ctx.peek_in_class() == ':' {
                // We have a character class.
                _ = ctx.next_n(2);  // Skip [:

                name: std::string = "";
                if !ctx.grab_until(":]", out name) { return ctx.error("Could not find end of character class."); }
                if supported_classes.end() == std::find(supported_classes.begin(), supported_classes.end(), name) {
                    return ctx.error("Unsupported character class. Supported ones are: (ctx.join(supported_classes))$");
                }

                classes.push_back("[:(name)$:]");

                _ = ctx.next(); // Skip ':' pointing to the ending ']'.
            }
            else if ctx.current() == '\\' {
                if ctx.next_no_skip()  && (ctx.current() != ']') {
                    if  ' ' == ctx.current() && ctx.get_modifiers().perl_code_syntax && ctx.get_modifiers().perl_code_syntax_in_classes {
                        classes.push_back(std::string(1, ctx.current())); // TODO: UFCS error with char as argument.
                    }
                    else {
                        name := "";
                            if 'd' == ctx.current() { name = "short_digits"; }
                        else if 'D' == ctx.current() { name = "short_not_digits"; }
                        else if 'h' == ctx.current() { name = "short_hor_space"; }
                        else if 'H' == ctx.current() { name = "short_not_hor_space"; }
                        else if 's' == ctx.current() { name = "short_space"; }
                        else if 'S' == ctx.current() { name = "short_not_space"; }
                        else if 'v' == ctx.current() { name = "short_ver_space"; }
                        else if 'V' == ctx.current() { name = "short_not_ver_space"; }
                        else if 'w' == ctx.current() { name = "short_word"; }
                        else if 'W' == ctx.current() { name = "short_not_word"; }
                        else {
                            return ctx.error("Unknown group escape.");
                        }
                        classes.push_back("[:(name)$:]");
                    }
                } else {
                    return ctx.error("Escape without a following character.");
                }
            }
            else if ctx.current() == '-' {
                if first { // Literal if first entry.
                    classes.push_back("(ctx.current())$");
                } else {
                    range = true;
                }
            }
            else {
                if range { // Modify last element to be a range.
                    classes.back() += "-(ctx.current())$";
                    range = false;
                }
                else {
                    classes.push_back("(ctx.current())$");
                }
            }

            first = false;
        }

        if ctx.current() != ']' {
            return ctx.error("Error end of character class definition before terminating ']'.");
        }
        end_pos := ctx.get_pos();

        if range { // If '-' is last entry treat it as a literal char.
            classes.push_back("-");
        }

        // Second step: Wrap the item on the class stack with corresponding class implementation.
        for classes do (inout cur) {
            if cur.starts_with("[:") {
                name := cur.substr(2, cur.size() - 4);
                cur = create_matcher("(name)$_class", "");
            }
            else if 1 != cur.size() {
                cur = create_matcher("range_class_entry", "'(cur[0])$', '(cur[2])$'");
            }
            else {
                cur = create_matcher("single_class_entry", "'(cur)$'");
            }
        }

        inner := ctx.join(classes);
        return shared.new<class_token>(is_negate, inner, ctx.get_range(start_pos, end_pos));
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx.add_check("class_token_matcher<char, (negate)$, (class_str)$>::match((ctx.match_parameters())$)");
    }


    private create_matcher: (name: std::string, template_arguments: std::string) -> std::string = {
        sep := ", ";
        if template_arguments.empty() { sep = ""; }

        return "::cpp2::regex::(name)$<char(sep)$(template_arguments)$>";
    }
}

class_token_matcher: <CharT, negate: bool, List ...> type =
{
    match: (inout cur, inout ctx, modifiers) -> bool = {
        if modifiers.has_flag(expression_flags::case_insensitive) {
            if cur != ctx.end && negate != ( match_any<List...>(safe_tolower(cur*)) || match_any<List...>(safe_toupper(cur*))) {
                cur += 1;
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if cur != ctx.end && negate != match_any<List...>(cur*) {
                cur += 1;
                return true;
            }
            else {
                return false;
            }
        }
    }

    private match_any: <First, Other ...> (c: CharT) -> bool = {
        r: bool = First::includes(c);

        if !r {
            if constexpr 0 != sizeof...(Other) {
                r = match_any<Other...>(c);
            }
        }

        return r;
    }

    // TODO: Implement proper to string
    // to_string: () -> bstring<CharT> = {
    //     r: bstring<CharT> = "[";
    //     if negate {
    //         r += "^";
    //     }
    //     r += (bstring<CharT>() + ... + List::to_string());
    //     r += "]";

    //     return r;
    // }
}

escape_token_parse: (inout ctx: parse_context) -> token_ptr = {
    if ctx.current() != '\\' { return nullptr; }


    if std::string::npos == std::string("afenrt^.[]()*{}?+|\\").find(ctx.peek()) {
        return nullptr;
    }

    _ = ctx.next(); // Skip escape

    if std::string::npos != std::string("afenrt").find(ctx.current()) {
        // Escape of string special char
        return shared.new<escaped_char_token>(ctx.current());
    } else {
        // Escape of regex special char
        r := shared.new<char_token>(ctx.current());
        r*.set_string("\\\\(ctx.current())$");

        return r;
    }

}

escaped_char_token: @polymorphic_base type = {
    this: regex_token_base;

    token: char;

    operator=: (out this, t: char) = {
        regex_token_base = "\\\\(t)$";
        token = t;
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        return shared.new<char_token>(ctx.current());
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx.add_check("char_token_matcher<char, '\\(token)$', '\\(token)$', '\\(token)$'>((ctx.match_parameters())$)");
    }
}

// Regex syntax: \K Example: ab\Kcd
//
global_group_reset_token_parse: (inout ctx: parse_context) -> token_ptr = {
    if !(ctx.current() == '\\' && ctx.peek() == 'K') { return nullptr; }

    _ = ctx.next(); // Skip escape.
    return shared.new<regex_token_code>("\\\\K", "ctx.set_group_start(0, r.pos);");
}

// Regex syntax: \<number>  Example: \1
//               \g{name_or_number}
//               \k{name_or_number}
//               \k<name_or_number>
//               \k'name_or_number'
//
group_ref_token: @polymorphic_base type = {
    this: regex_token_base = ();

    id: int;

    operator=:(out this, id_: int, str: std::string) = {
        regex_token_base = str;
        id = id_;
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        if ctx.current() != '\\' { return nullptr; }

        str : std::string = "\\\\";
        group : std::string = "";

        if '0' <= ctx.peek() <= '9' {
            _ = ctx.next(); // Skip escape
            group = ctx.grab_number();
            if group.ssize() >= 3 {
                // Octal syntax (\000) not a group ref matcher.
                number := 0;
                if !string_to_int(group, number, 8) { return ctx.error("Could not convert octal to int."); }

                number_as_char : char = unsafe_narrow<char>(number);

                token := shared.new<char_token>(number_as_char);
                token*.set_string("\\(int_to_string(number_as_char as int, 8))$");

                return token;
            }

            str += group;
            // Regular group ref
        }
        else if 'g' == ctx.peek() {
            _ = ctx.next(); // Skip escape
            if !ctx.next() { return ctx.error("Group escape without a following char."); } // Skip g

            str += "g";

            if ctx.current() == '{' {
                str += "{";
                if !(ctx.next() && ctx.grab_until('}', out group)) { return ctx.error("No ending bracket."); }

                str += group + "}";
            }
            else {
                group = ctx.grab_number();
                str += group;
            }
        }
        else if 'k' == ctx.peek() {
            _ = ctx.next(); // Skip escape
            if !ctx.next() { return ctx.error("Group escape without a following char."); } // Skip k

            str += "k";

            term_char := '\0';
            if ctx.current() == '{' { term_char = '}'; }
            else if ctx.current() == '<' { term_char = '>'; }
            else if ctx.current() == '\'' { term_char = '\''; }
            else {
                return ctx.error("Group escape has wrong operator.");
            }

            str += ctx.current();

            if !(ctx.next() && ctx.grab_until(term_char, out group)) { return ctx.error("No ending bracket."); }

            str += group + term_char;
        }
        else {
            // No group ref matcher
            return nullptr;
        }

        // Parse the group
        group = trim_copy(group);
        group_id : int = 0;
        if string_to_int(group, group_id) {
            if group_id < 0 {
                group_id = ctx.get_cur_group() + group_id;

                if group_id < 1 { // Negative and zero are no valid groups.
                    return ctx.error("Relative group reference does not reference a valid group. (Would be (group_id)$.)");
                }
            }

            if group_id >= ctx.get_cur_group() {
                return ctx.error("Group reference is used before the group is declared.");
            }
        }
        else {
            // Named group
            group_id = ctx.get_named_group(group);
            if -1 == group_id { return ctx.error("Group names does not exist. (Name is: (group)$)");}
        }

        return shared.new<group_ref_token>(group_id, str);
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx.add_check("group_ref_token_matcher<char, (id)$>((ctx.match_parameters())$)");
    }
}

group_ref_token_matcher: <CharT, group: int> (inout cur, inout ctx, modifiers) -> bool = {
    g := ctx.get_group(group);

    group_pos := g.start;
    while group_pos != g.end && cur != ctx.end next (group_pos++, cur++) {
        if modifiers.has_flag(expression_flags::case_insensitive) {
            if safe_tolower(group_pos*) != safe_tolower(cur*) {
                return false;
            }
        }
        else {
            if group_pos* != cur* {
                return false;
            }
        }
    }

    if group_pos == g.end {
        return true;
    }
    else {
        return false;
    }
}

group_token: @polymorphic_base type = {
    this: regex_token = ();

    number: int      = -1;
    inner: token_ptr = nullptr;
    mod: std::string = "::cpp2::regex::match_modifiers_no_change";

    parse_lookahead: (inout ctx: parse_context, syntax: std::string, positive: bool) -> token_ptr = {
        _ = ctx.next(); // Skip last token defining the syntax

        r := shared.new<lookahead_token>(positive);

        old_state := ctx.start_group();
        if !ctx.parse_until(')') { return ctx.error("Lookahead without a closing bracket."); }
        r*.inner = ctx.end_group(old_state);
        r*.set_string("((syntax)$(r*.inner*.to_string())$)");

        return r;
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        if ctx.current() != '(' { return nullptr; }

        has_id :=  ctx.get_modifiers().group_captures_have_numbers;
        has_pattern := true;
        group_name : std::string = "";
        group_name_brackets := true;
        modifier_change: std::string = "::cpp2::regex::match_modifiers_no_change";
        modifiers : std::string = "";

        modifiers_change_to : =  ctx.get_modifiers();

        // Skip the '('
        if !ctx.next() { return ctx.error("Group without closing bracket."); }
        if ctx.current() == '?' {
            // Special group
            if !ctx.next_no_skip() { return ctx.error("Missing character after group opening.");  }

            if ctx.current() == '<' || ctx.current() == '\'' {
                // named group
                end_char := ctx.current();
                if end_char == '<' {
                    end_char = '>';
                } else {
                    group_name_brackets = false;
                }
                has_id = true; // Force id for named groups.
                if !ctx.next() /* skip '<' */ { return ctx.error("Missing ending bracket for named group.");  }
                if !ctx.grab_until(end_char, out group_name) { return ctx.error("Missing ending bracket for named group.");  }
                if !ctx.next() { return ctx.error("Group without closing bracket."); }
            }
            else if ctx.current() == '#' {
                // Comment
                comment_str : std::string = "";
                if !ctx.grab_until(")", out comment_str) { return ctx.error("Group without closing bracket."); }
                // Do not add comment. Has problems with ranges.

                return shared.new<regex_token_empty>("(?#(comment_str)$)");
            }
            else if ctx.current() == '|' {
                // Branch reset group

                if !ctx.next() /* skip '|' */ { return ctx.error("Missing ending bracket for named group.");  }

                old_parser_state := ctx.start_group();
                old_branch_state  := ctx.branch_reset_new_state();
                if !ctx.parse_until(')') { return nullptr; }
                ctx.branch_reset_restore_state(old_branch_state);
                inner_ := ctx.end_group(old_parser_state);

                list: token_vec = (shared.new<regex_token_empty>("(?|"), inner_, shared.new<regex_token_empty>(")"));
                return shared.new<regex_token_list>(list);
            }
            else if ctx.current() == '=' || ctx.current() == '!' {
                return parse_lookahead(ctx, "?(ctx.current())$", ctx.current() == '=');
            }
            else {
                // Simple modifier
                has_id = false;
                if !ctx.grab_until_one_of("):", out modifiers) { return ctx.error("Missing ending bracket for group."); }
                if !ctx.parser_group_modifiers(modifiers, out modifier_change, modifiers_change_to) {
                     return nullptr;
                }

                if ')' == ctx.current() {
                    has_pattern = false;
                }
                else {
                    if !ctx.next() /* skip ':' */ { return ctx.error("Missing ending bracket for group.");  }
                }
            }
        }
        else if ctx.current() == '*' {
            // named pattern
            _ = ctx.next(); // Skip *.
            name: std::string = "";
            if !ctx.grab_until(':', out name) { return ctx.error("Missing colon for named pattern.");  }

            if name == "pla" || name == "positive_lookahead" {
                return parse_lookahead(ctx, "*(name)$:", true);
            }
            else if name == "nla" || name == "negative_lookahead" {
                return parse_lookahead(ctx, "*(name)$:", false);
            }
            else {
                return ctx.error("Unknown named group pattern: '(name)$'");
            }
        }

        if has_pattern {
            // regular group

            r := shared.new<group_token>();
            if has_id {
                r*.number = ctx.next_group();

                if 0 != group_name.size() {
                    ctx.set_named_group(group_name, r*.number);
                }
            }

            old_state := ctx.start_group();
            ctx.set_modifiers(modifiers_change_to);
            if !ctx.parse_until(')') { return nullptr; }
            r*.inner = ctx.end_group(old_state);
            r*.set_string(gen_string(group_name, group_name_brackets, modifiers, r*.inner));
            r*.mod = modifier_change;

            return r;
        }
        else {
            // Only a modifier
            ctx.set_modifiers(modifiers_change_to);

            return shared.new<modifier_token>(modifier_change);
        }
    }

    gen_string: (name: std::string, name_brackets: bool, modifiers: std::string, inner_: token_ptr) -> std::string = {
        start : std::string = "(";
        if 0 != name.size() {
            if name_brackets {
                start += "?<(name.data())$>";
            }
            else {
                start += "?'(name.data())$'";
            }
        }
        else if ! modifiers.empty() {
            start += "?" + modifiers + ":";
        }

        return start + inner_*.to_string() + ")";
    }

    generate_code: (override this, inout ctx: generation_context) = {
        if -1 != number {
            ctx.add("ctx.set_group_start((number)$, r.pos);");
        }

        next_name := ctx.next_func_name();
        ctx.add_statefull(next_name, "cpp2::regex::apply_modifiers_matcher<char, true, (mod)$>::match((ctx.match_parameters())$, other, (next_name)$)");

        inner*.generate_code(ctx);
        if -1 != number {
            ctx.add("ctx.set_group_end((number)$, r.pos);");
            tmp_name := ctx.gen_temp();
            ctx.add("(tmp_name)$ :=  cpp2::regex::make_on_return(:() = {");
            ctx.add("  if !r&$*.matched {");
            ctx.add("    ctx&$*.set_group_invalid((number)$);");
            ctx.add("  }");
            ctx.add("});");
            ctx.add("_ = (tmp_name)$;"); // TODO: Guard object problem.
        }

        next_name = ctx.next_func_name();
        ctx.add_statefull(next_name, "cpp2::regex::pop_modifiers_matcher<char>::match((ctx.match_parameters())$, other, (next_name)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner*.add_groups(groups);
        if -1 != number {
            _ = groups.insert(number);
        }
    }
}

// Regex syntax: \x<number> or \x{<number>}  Example: \x{62}
//
hexadecimal_token_parse: (inout ctx: parse_context) -> token_ptr = {
    if !(ctx.current() == '\\' && ctx.peek() == 'x') { return nullptr; }

    _ = ctx.next(); // Skip escape.

    if !ctx.next() { return ctx.error("x escape without number.");}

    has_brackets := false;
    number_str: std::string = "";
    if '{' == ctx.current() {
        // TODO: Currently does not work since the compiler handles \x also.
        // Bracketed
        has_brackets = true;
        _  = ctx.next(); // Skip '{'
        if !ctx.grab_until('}', out number_str) { return ctx.error("No ending bracket for \\x"); }
    }
    else {
        // grab two chars

        if !ctx.grab_n(2, out number_str) { return ctx.error("Missing hexadecimal digits after \\x."); }
    }

    number := 0;
    if !string_to_int(number_str, number, 16) { return ctx.error("Could not convert hexadecimal to int."); }

    // TODO: Change for unicode.
    number_as_char : char = unsafe_narrow<char>(number);

    syntax: std::string = int_to_string(number_as_char as int, 16);
    if has_brackets {
        syntax = "{(syntax)$}";
    }
    syntax = "\\\\x(syntax)$";

    r := shared.new<char_token>(number_as_char);
    r*.set_string(syntax);
    return r;
}

modifier_token: @polymorphic_base type = {
    this: regex_token_base;

    mod: std::string;

    operator=: (out this, mod_: std::string) = {
        regex_token_base = ("(?(mod_)$)");
        mod = mod_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        next_name := ctx.next_func_name();
        ctx.add_statefull(next_name, "cpp2::regex::apply_modifiers_matcher<char, false, (mod)$>::match((ctx.match_parameters())$, other, (next_name)$)");
    }
}

apply_modifiers_matcher: <CharT, push: bool, ModifierChange> type = {

    match: <Iter, Modifiers> (cur: Iter, inout ctx, _: Modifiers, end_func, tail) -> _ = {
        if constexpr push {
            return tail(cur, ctx, Modifiers::push(ModifierChange()), end_func);
        }
        else {
            return tail(cur, ctx, Modifiers::replace(ModifierChange()), end_func);
        }
    }
}

pop_modifiers_matcher: <CharT> type = {

    match: <Iter, Modifiers> (cur: Iter, inout ctx, _: Modifiers, end_func, tail) -> _ = {
        return tail(cur, ctx, Modifiers::pop(), end_func);
    }
}

// Regex syntax: $  Example: aa$
//
line_end_token_parse: (inout ctx: parse_context) -> token_ptr = {
    if ctx.current() == '$' || (ctx.current() == '\\' && ctx.peek() == '$') {
        if (ctx.current() == '\\') { _ = ctx.next(); } // Skip escape
        return shared.new<regex_token_check>("\\\\$", "line_end_token_matcher<char, true, true>");
    }
    else if ctx.current() == '\\' && (ctx.peek() == 'z' || ctx.peek() == 'Z') {
        _ = ctx.next(); // Skip escape

        negate := ctx.current() == 'Z';
        return shared.new<regex_token_check>("\\\\(ctx.current())$", "line_end_token_matcher<char, false, (negate)$>");
    }
    else {
        return nullptr;
    }
}

line_end_token_matcher: <CharT, match_new_line: bool, match_new_line_before_end: bool> (cur, inout ctx, modifiers) -> bool = {
    if cur == ctx.end || (match_new_line && modifiers.has_flag(expression_flags::multiple_lines) && cur* == '\n') {
        return true;
    }
    else if match_new_line_before_end && (cur* == '\n' && (cur + 1) == ctx.end) { // Special case for new line at end.
        return true;
    }
    else {
        return false;
    }
}

// Regex syntax: ^  Example: ^aa
//
line_start_token_parse: (inout ctx: parse_context) -> token_ptr = {
    if ctx.current() != '^' && !(ctx.current() == '\\' && ctx.peek() == 'A') { return nullptr; }

    if ctx.current() == '\\' {
        _ = ctx.next();
        return shared.new<regex_token_check>("\\\\A", "line_start_token_matcher<char, false>");
    }
    else {
        return shared.new<regex_token_check>("^", "line_start_token_matcher<char, true>");
    }
}

line_start_token_matcher: <CharT, match_new_line: bool> (cur, inout ctx, modifiers) -> bool = {
    return cur == ctx.begin || // Start of string
           (match_new_line && modifiers.has_flag(expression_flags::multiple_lines)  && (cur - 1)* == '\n'); // Start of new line
}

// Regex syntax: (?=) or (?!) or (*pla), etc.  Example: (?=AA)
//
lookahead_token: @polymorphic_base type = {
    this: regex_token = ("");

    protected positive: bool;
    public inner: token_ptr = nullptr;

    operator=: (out this, positive_: bool) = {
        positive = positive_;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        inner_name := ctx.generate_func(inner);

        ctx.add_check("lookahead_token_matcher<char, (positive)$>((ctx.match_parameters())$, (inner_name)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner*.add_groups(groups);
    }
}

lookahead_token_matcher: <CharT, positive: bool> (cur, inout ctx, modifiers, func) -> bool = {
    r := func(cur, ctx, modifiers, true_end_func());
    if !positive {
        r.matched = !r.matched;
    }

    return r.matched;
}

// Named character classes
//

named_class_token_parse: (inout ctx: parse_context) -> token_ptr = {
    if ctx.current() != '\\' { return nullptr; }

    name := "";
    c_next := ctx.peek();

    if 'd' == c_next { name = "named_class_digits"; }
    else if 'D' == c_next { name = "named_class_not_digits"; }
    else if 'h' == c_next { name = "named_class_hor_space"; }
    else if 'H' == c_next { name = "named_class_not_hor_space"; }
    else if 'N' == c_next { name = "named_class_no_new_line"; }
    else if 's' == c_next { name = "named_class_space"; }
    else if 'S' == c_next { name = "named_class_not_space"; }
    else if 'v' == c_next { name = "named_class_ver_space"; }
    else if 'V' == c_next { name = "named_class_not_ver_space"; }
    else if 'w' == c_next { name = "named_class_word"; }
    else if 'W' == c_next { name = "named_class_not_word"; }
    else { return nullptr; }

    _ = ctx.next(); // Skip escape

    return shared.new<regex_token_check>("\\\\(ctx.current())$", "(name)$<char>::match");
}

named_class_no_new_line: <CharT> type == class_token_matcher<CharT, true, single_class_entry<CharT, '\n'>>;
named_class_digits     : <CharT> type == class_token_matcher<CharT, false, digits_class<CharT>>;
named_class_hor_space  : <CharT> type == class_token_matcher<CharT, false, hor_space_class<CharT>>;
named_class_space      : <CharT> type == class_token_matcher<CharT, false, space_class<CharT>>;
named_class_ver_space  : <CharT> type == class_token_matcher<CharT, false, ver_space_class<CharT>>;
named_class_word       : <CharT> type == class_token_matcher<CharT, false, word_class<CharT>>;

named_class_not_digits    : <CharT> type == class_token_matcher<CharT, true, digits_class<CharT>>;
named_class_not_hor_space : <CharT> type == class_token_matcher<CharT, true, hor_space_class<CharT>>;
named_class_not_space     : <CharT> type == class_token_matcher<CharT, true, space_class<CharT>>;
named_class_not_ver_space : <CharT> type == class_token_matcher<CharT, true, ver_space_class<CharT>>;
named_class_not_word      : <CharT> type == class_token_matcher<CharT, true, word_class<CharT>>;


// Regex syntax: \o{<number>}  Example: \o{142}
//
octal_token_parse: (inout ctx: parse_context) -> token_ptr = {
    if !(ctx.current() == '\\' && ctx.peek() == 'o') { return nullptr; }

    _ = ctx.next(); // Skip escape.

    if !ctx.next() { return ctx.error("o escape without number.");}
    if ctx.current() != '{' { return ctx.error("Missing opening bracket for \\o."); }

    number_str: std::string = "";
    _  = ctx.next(); // Skip '{'
    if !ctx.grab_until('}', out number_str) { return ctx.error("No ending bracket for \\o"); }

    number := 0;
    if !string_to_int(number_str, number, 8) { return ctx.error("Could not convert octal to int."); }

    // TODO: Change for unicode.
    number_as_char : char = unsafe_narrow<char>(number);

    syntax: std::string = "\\o{(int_to_string(number_as_char as int, 8))$}";
    r := shared.new<char_token>(number_as_char);
    r*.set_string(syntax);
    return r;
}

// Regex syntax: <matcher>{min, max}  Example: a{2,4}
//
range_token: @polymorphic_base type = {
    this: regex_token = ("");

    protected min_count: int = -1;
    protected max_count: int = -1;
    protected kind:      int = range_flags::greedy;
    protected inner_token: token_ptr = nullptr;

    operator=: (out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr = {
        r := shared.new<range_token>();
        if ctx.current() == '{' {
            if !ctx.has_token() { return ctx.error("'{' without previous element."); }

            inner: std::string = "";
            if !ctx.grab_until('}', out inner) { return ctx.error("Missing closing bracket '}'."); }

            inner = trim_copy(inner.substr(1)); // Remove '{' and white spaces.
            if inner.empty() { return ctx.error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'"); }

            // Non-greedy or possessive
            r*.parse_modifier(ctx);

            // Get range arguments
            min_count_str: std::string = "-1";
            max_count_str: std::string = "-1";

            sep: size_t = inner.find(",");
            if sep == std::string::npos {
                min_count_str = inner;
                max_count_str = inner;
                if !string_to_int(inner, r*.min_count) { return ctx.error("Could not convert range to number."); }
                r*.max_count = r*.min_count;
            }
            else {
                inner_first: std::string = trim_copy(inner.substr(0, sep));
                inner_last: std::string = trim_copy(inner.substr(sep + 1));

                if (inner_first.empty() && inner_last.empty()) {
                    return ctx.error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'");
                }

                if !inner_first.empty() {
                    min_count_str = inner_first;
                    if !string_to_int(inner_first, r*.min_count) { return ctx.error("Could not convert range to number."); }
                }
                if !inner_last.empty() {
                    max_count_str = inner_last;
                    if !string_to_int(inner_last, r*.max_count) { return ctx.error("Could not convert range to number."); }
                }
            }


            // Check validity of the range.
            if -1 != r*.min_count {
                if !(0 <= r*.min_count) {
                    return ctx.error("Min value in range is negative. Have (r*.min_count)$)");
                }
            }
            if -1 != r*.max_count {
                if !(0 <= r*.max_count) {
                    return ctx.error("Max value in range is negative. Have (r*.max_count)$)");
                }
                if -1 != r*.min_count {
                    if !(r*.min_count <= r*.max_count) {
                        return ctx.error("Min and max values in range are wrong it should hold 0 <= min <= max. Have 0 <= (r*.min_count)$ <= (r*.max_count)$");
                    }
                }
            }

            r*.inner_token = ctx.pop_token();
            r*.string_rep = r*.inner_token*.to_string() + r*.gen_range_string() + r*.gen_mod_string();

            return r;
        }

        return nullptr;
    }

    parse_modifier: (inout this, inout ctx: parse_context) = {
        if ctx.peek() == '?' {
            kind = range_flags::not_greedy;
            _ = ctx.next();
        }
        else if ctx.peek() == '+' {
            kind = range_flags::possessive;
            _ = ctx.next();
        }
    }

    gen_mod_string: (this) -> std::string = {
        if kind == range_flags::not_greedy {
            return "?";
        }
        else if kind == range_flags::possessive {
            return "+";
        }
        else {
            return "";
        }
    }

    gen_range_string: (this) -> std::string = {
        r : std::string = "";
        if min_count == max_count {
            r += "{(min_count)$}";
        }
        else if min_count == -1 {
            r += "{,(max_count)$}";
        }
        else if max_count == -1 {
            r += "{(min_count)$,}";
        }
        else {
            r += "{(min_count)$,(max_count)$}";
        }

        if kind == range_flags::not_greedy {
            r += "?";
        }
        else if kind == range_flags::possessive {
            r += "+";
        }
        return r;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        inner_name := ctx.generate_func(inner_token);
        groups: std::set<int> = ();
        inner_token*.add_groups(groups);
        reset_name := ctx.generate_reset(groups);

        next_name := ctx.next_func_name();
        ctx.add_statefull(next_name, "cpp2::regex::range_token_matcher<char, (min_count)$, (max_count)$, (kind)$>::match((ctx.match_parameters())$, (inner_name)$, (reset_name)$, other, (next_name)$)");
    }

    add_groups: (override this, inout groups: std::set<int>) = {
        inner_token*.add_groups(groups);
    }

}

range_token_matcher: <CharT, min_count: int, max_count: int, kind: int> type = {

    match: <Iter> (cur: Iter, inout ctx, modifiers, inner, reset_func, end_func, tail) -> _ = {
        if range_flags::possessive == kind {
            return match_possessive(cur, ctx, modifiers, inner, end_func, tail);
        }
        else if range_flags::greedy == kind {
            return match_greedy(0, cur, ctx.end, ctx, modifiers, inner, reset_func, end_func, tail);
        }
        else { // range_flags::not_greedy == kind
            return match_not_greedy(cur, ctx, modifiers, inner, end_func, tail);
        }
    }

    private is_below_upper_bound: (count: int) -> bool = {
        if -1 == max_count { return true; }
        else { return count < max_count; }
    }

    private is_below_lower_bound: (count: int) -> bool = {
        if -1 == min_count { return false; }
        else { return count < min_count; }
    }

    private is_in_range: (count: int) -> bool = {
        if -1 != min_count && count < min_count { return false; }
        if -1 != max_count && count > max_count { return false; }
        return true;
    }

    private match_min_count: <Iter> (cur: Iter, inout ctx, modifiers, inner, end_func, inout count_r: int) -> _ = { // TODO: count_r as out parameter introduces a performance loss.
        res := ctx.pass(cur);
        count := 0;

        while is_below_lower_bound(count) && res.matched {
            res = inner(res.pos, ctx, modifiers, end_func);
            if res.matched {
                count += 1;
            }
        }

        count_r = count;
        return res;
    }

    private match_greedy: <Iter> (count: int, cur: Iter, last_valid: Iter, inout ctx, modifiers, inner, reset_func, end_func, other) -> match_return<Iter> = {
        inner_call := :(tail_cur, inout tail_ctx, _ /* ignore new modifiers */) -> _ == {
            return match_greedy((count + 1)$, tail_cur, (cur)$, tail_ctx, (modifiers)$, (inner)$, (reset_func)$, (end_func)$, (other)$);
        };
        is_m_valid := true;
        r := ctx.fail();
        if is_below_upper_bound(count) && (is_below_lower_bound(count) || cur != last_valid) {
            is_m_valid = false;  // Group ranges in M are invalidated through the call.
            r = inner(cur, ctx, modifiers, inner_call);
        }

        if !r.matched && is_in_range(count) {
            // The recursion did not yield a match try now the tail
            r = other(cur, ctx, modifiers, end_func);

            if r.matched && !is_m_valid{
                // We have a match rematch M if required
                reset_func(ctx);

                if count > 0 {
                    _ = inner(last_valid, ctx, modifiers, end_func);
                }
            }
        }

        return r;
    }

    private match_possessive: <Iter>(cur: Iter, inout ctx, modifiers, inner, end_func, other) -> match_return<Iter> = {
        count :=0;
        r := match_min_count(cur, ctx, modifiers, inner, end_func, count);

        if !r.matched {
          return r;
        }

        pos := r.pos;
        while r.matched && is_below_upper_bound(count) {
            r = inner(pos, ctx, modifiers, true_end_func());

            if pos == r.pos {
                break; // Break infinite loop.
            }
            if r.matched {
                count += 1;
                pos = r.pos;
            }
        }

        return other(pos, ctx, modifiers, end_func);
    }

    private match_not_greedy: <Iter> (cur: Iter, inout ctx, modifiers, inner, end_func, other) -> match_return<Iter> = {
        count := 0;
        start := match_min_count(cur, ctx, modifiers, inner, end_func, count);
        if !start.matched {
          return start;
        }

        pos := start.pos;
        while is_below_upper_bound(count) {
            o:= other(pos, ctx, modifiers, end_func);
            if o.matched {
                return o;
            }

            r:= inner(pos, ctx, modifiers, end_func);
            if !r.matched {
                return ctx.fail();
            }
            count += 1;
            pos = r.pos;
        }

        return other(pos, ctx, modifiers, end_func); // Upper bound reached.
    }
}

// Regex syntax: *, +, or ?  Example: aa*
//
special_range_token: @polymorphic_base type = {
    this : range_token = ();

    parse: (inout ctx: parse_context) -> token_ptr = {
        r := shared.new<special_range_token>();
        symbol: char = '\0';
        if ctx.current() == '*' {
            r*.min_count = 0;
            r*.max_count = -1;
            symbol = '*';
        }
        else if ctx.current() == '+' {
            r*.min_count = 1;
            r*.max_count = -1;
            symbol = '+';
        } else if ctx.current() == '?' {
            r*.min_count = 0;
            r*.max_count = 1;
            symbol = '?';
        } else {
            return nullptr;
        }

        if !ctx.has_token() { return ctx.error("'(ctx.current())$' without previous element."); }


        r*.parse_modifier(ctx);

        r*.inner_token = ctx.pop_token();
        r*.string_rep = r*.inner_token*.to_string() + symbol + r*.gen_mod_string();
        return r;
    }
}

// Regex syntax: \b or \B  Example: \bword\b
//
// Matches the start end end of word boundaries.
//
word_boundary_token_parse: (inout ctx: parse_context) -> token_ptr = {
    if ctx.current() != '\\' { return nullptr; }

    if ctx.peek() == 'b' {
        _ = ctx.next();
        return shared.new<regex_token_check>("\\\\b", "word_boundary_token_matcher<char, false>");
    }
    else if ctx.peek() == 'B' {
        _ = ctx.next();
        return shared.new<regex_token_check>("\\\\B", "word_boundary_token_matcher<char, true>");
    }
    else {
        return nullptr;
    }
}

word_boundary_token_matcher: <CharT, negate: bool> (inout cur, inout ctx, modifiers) -> bool = {
    _ = modifiers;
    words : word_class<CharT> = ();
    is_match := false;
    if cur == ctx.begin { // String start
        if cur != ctx.end { // No empty string
            is_match = words.includes(cur*);
        }
    }
    else if cur == ctx.end { // String end
        is_match = words.includes((cur - 1)*);
    }
    else { // Middle of string
        is_match =
                (words.includes((cur - 1)*) && !words.includes(cur*))  // End of word: \w\W
            || (!words.includes((cur - 1)*) && words.includes(cur*)); // Start of word: \W\w

    }
    if negate {
        is_match = !is_match;
    }

    return is_match;
}


//-----------------------------------------------------------------------
//
//  Matchers for regular expressions.
//
//-----------------------------------------------------------------------
//


// Regex syntax: none Example: -
//
branch_reset_matcher_logic: <CharT> type = {
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) Other::match(cur, ctx, modifiers, end_func);
    reset_ranges: (_) = {}
    to_string:    ()  bstring<CharT>("(?|");
}

// Regex syntax: <any character>  Example: a
//
char_matcher_logic: <CharT, C: CharT, L: CharT, U: CharT> type =
{
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        if modifiers.has_flag(expression_flags::case_insensitive) {
            if cur != ctx.end && (cur* == L || cur* == U) {
                return Other::match(cur + 1, ctx, modifiers, end_func);
            }
            else {
                return ctx.fail();
            }
        }
        else {
            if cur != ctx.end && cur* == C {
                return Other::match(cur + 1, ctx, modifiers, end_func);
            }
            else {
                return ctx.fail();
            }
        }

    }
    reset_ranges: (_) = {}
    to_string:    ()  bstring<CharT>(1, C);
}


// Regex syntax: [<character classes>]  Example: [abcx-y[:digits:]]
//
class_matcher_logic: <CharT, negate: bool, List ...> type =
{
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        if modifiers.has_flag(expression_flags::case_insensitive) {
            if cur != ctx.end && negate != ( match_any<List...>(safe_tolower(cur*)) || match_any<List...>(safe_toupper(cur*))) {
                return Other::match(cur + 1, ctx, modifiers, end_func);
            }
            else {
                return ctx.fail();
            }
        }
        else {
            if cur != ctx.end && negate != match_any<List...>(cur*) {
                return Other::match(cur + 1, ctx, modifiers, end_func);
            }
            else {
                return ctx.fail();
            }
        }
    }

    private match_any: <First, Other ...> (c: CharT) -> bool = {
        r: bool = First::includes(c);

        if !r {
            if constexpr 0 != sizeof...(Other) {
                r = match_any<Other...>(c);
            }
        }

        return r;
    }

    reset_ranges: (_) = {}

    to_string: () -> bstring<CharT> = {
        r: bstring<CharT> = "[";
        if negate {
            r += "^";
        }
        r += (bstring<CharT>() + ... + List::to_string());
        r += "]";

        return r;
    }
}


//-----------------------------------------------------------------------
//
//  Regular expression implementation.
//
//-----------------------------------------------------------------------
//

// Regular expression implementation
regular_expression: <CharT, Matcher> type = {

    context: <Iter> type == match_context<CharT, Iter, Matcher::group_count::value, 0>;
    modifiers: type      == match_modifiers<Matcher::initial_flags::value, int>;

    // TODO: Named multiple return has problems with templates.
    search_return: <Iter> type = {
        public matched: bool;
        public ctx: context<Iter>;

        operator=:(out this, matched_: bool, ctx_: context<Iter>) = {
            matched = matched_;
            ctx = ctx_;
        }

        group_number: (this) ctx.size();
        group:        (this, g: int) ctx.get_group_string(g);
        group_start:  (this, g: int) ctx.get_group_start(g);
        group_end:    (this, g: int) ctx.get_group_end(g);

        group:        (this, g: bstring<CharT>) group(get_group_id(g));
        group_start:  (this, g: bstring<CharT>) group_start(get_group_id(g));
        group_end:    (this, g: bstring<CharT>) group_end(get_group_id(g));

        private get_group_id: (this, g: bstring<CharT>) -> _ = {
            group_id := Matcher::get_named_group_index(g);
            if -1 == group_id {
                // TODO: Throw error.
            }
            return group_id;
        }
    }

    match: (in this, str: bview<CharT>)                 match(str.begin(), str.end());
    match: (in this, str: bview<CharT>, start)          match(get_iter(str, start), str.end());
    match: (in this, str: bview<CharT>, start, length)  match(get_iter(str, start), get_iter(str, start + length));
    match: <Iter> (in this, start: Iter, end: Iter) -> search_return<Iter> = {
        ctx: context = (start, end);

        r := Matcher::entry(start, ctx, modifiers());
        return search_return(r.matched && r.pos == end, ctx);
    }

    search: (in this, str: bview<CharT>)                 search(str.begin(), str.end());
    search: (in this, str: bview<CharT>, start)          search(get_iter(str, start), str.end());
    search: (in this, str: bview<CharT>, start, length)  search(get_iter(str, start), get_iter(str, start + length));
    search: <Iter> (in this, start: Iter, end: Iter) -> search_return<Iter> = {
        matched := false;
        ctx: context = (start, end);

        cur:= start;
        while true next (cur++) {
            if Matcher::entry(cur, ctx, modifiers()).matched {
                matched = true;
                break;
            }

            if cur == ctx.end {
                break;
            }
        }

        return search_return(matched, ctx);
    }

    to_string: (in this) Matcher::to_string();

    // Helper functions
    //

    private get_iter: (str: bview<CharT>, pos) -> _ = {
        if pos < str.size() {
            return str.begin() + pos;
        }
        else {
            return str.end();
        }
    }
}

//-----------------------------------------------------------------------
//
//  Parser for regular expression.
//
//-----------------------------------------------------------------------
//

// Parser and generator for regular expressions.
regex_parser: <Error_out> type = {

    regex:     std::string_view;
    modifier:  std::string_view;
    error_out: Error_out;

    pos:                    size_t = 0;
    alternatives_count:     int = 0;
    named_groups :          std::map<std::string, int> = ();
    has_error:              bool = false;

    source: std::string = "";



    operator=: (out this, r: std::string_view, m: std::string_view, e: Error_out) = {
        this.regex = r;
        this.modifier = m;
        this.error_out = e;
    }

    // Misc functions
    //
    error:(inout this, message: std::string) = {
        error_out("Error during parsing of regex '(regex)$' at position '(pos)$': (message)$");
        has_error = true;
    }

    // Parser helper functions.

    parser_expression_modifiers: (inout this, out mods : parse_context_modifier_state) -> std::string = {
        r: std::string = "0";
        sep: std::string = " | ";

        add := :(name, inout r) = {
            r += "(sep$)$(name)$";
        };

        mods = ();

        mod_pos := 0;
        while mod_pos < modifier.ssize() next mod_pos += 1 {
            c: char = modifier[mod_pos];

            if      c == 'i' { add("::cpp2::regex::expression_flags::case_insensitive", r); }
            else if c == 'm' { add("::cpp2::regex::expression_flags::multiple_lines", r); }
            else if c == 's' { add("::cpp2::regex::expression_flags::single_line", r); }
            else if c == 'n' {
                add("::cpp2::regex::expression_flags::no_group_captures", r);
                mods.group_captures_have_numbers = false;
            }
            else if c == 'x' {
                add("::cpp2::regex::expression_flags::perl_code_syntax", r);
                mods.perl_code_syntax = true;

                // Check if we have 'xx'
                mod_pos += 1;
                if mod_pos < modifier.ssize() && 'x' == modifier[mod_pos] {
                    add("::cpp2::regex::expression_flags::perl_code_syntax_in_classes", r);
                    mods.perl_code_syntax_in_classes = true;
                }
            }
            else { error("Unknown modifier: '(c)$'"); }
        }

        return r;
    }

    // Parsing functions
    //

    create_named_group_lookup: (this) -> std::string = {
        res: std::string = "get_named_group_index: (name) -> int = {\n";

        // Generate if selection.
        sep: std::string = "";
        for named_groups do (cur) {
            res += "(sep)$if name == \"(cur.first)$\" { return (cur.second)$; }";
            sep = "else ";
        }

        // Generate else branch or return if list is empty.
        if named_groups.empty() {
            res += "  _ = name;\n";
            res += "  return -1;\n";
        }
        else {
            res += "  else { return -1; }\n";
        }
        res += "}\n";
        return res;
    }

    parse:(inout this) -> std::string = {
        modifiers : parse_context_modifier_state;
        mod   := parser_expression_modifiers(out modifiers);
        parse_ctx: parse_context = (regex, modifiers);
        if !parse_ctx.parse() {
            error(parse_ctx.error_text);
            return "Error";
        }

        source += "{\n";
        source += "  group_count: type == std::integral_constant<int, (parse_ctx.get_cur_group())$>;  //TODO: Use static constexpr when alpha limitation of nested types declarations is lifted.\n";
        source += "  initial_flags: type == std::integral_constant<int, (mod)$>;  //TODO: Use static constexpr when alpha limitation of nested types declarations is lifted.\n";

        gen_ctx: generation_context = ();
        source += gen_ctx.run(parse_ctx.get_tokens());
        source += "  entry: (cur, inout ctx, modifiers) -> _ = {\n";
        source += "    ctx.set_group_start(0, cur);\n";
        source += "    r := (gen_ctx.get_entry_func())$(cur, ctx, modifiers, cpp2::regex::true_end_func());\n";
        source += "    if r.matched { ctx.set_group_end(0, r.pos); }\n";
        source += "    return r;\n";
        source += "  }\n";

        string := parse_ctx.get_tokens()*.to_string();
        source += "  to_string: () -> std::string = { return \"(string)$\"; }\n";
        source += create_named_group_lookup();
        source += "}\n";

        _ = parse_ctx;

        std::cout << source << std::endl;

        return source;
    }
}

generate_template: <Err> (regex: std::string_view, modifier: std::string_view, err: Err) -> std::string = {
    parser: regex_parser<Err> = (regex, modifier, err);
    r := parser.parse();
    _ = parser;
    return r;
}

}
}
