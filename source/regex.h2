
//  Copyright (c) Herb Sutter
//  SPDX-License-Identifier: CC-BY-NC-ND-4.0

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// From https://stackoverflow.com/questions/216823/how-to-trim-a-stdstring

// trim from start (in place)
static inline void ltrim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) {
        return !std::isspace(ch);
    }));
}

// trim from end (in place)
static inline void rtrim(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) {
        return !std::isspace(ch);
    }).base(), s.end());
}

// trim from both ends (in place)
static inline void trim(std::string &s) {
    rtrim(s);
    ltrim(s);
}

// trim from start (copying)
static inline std::string ltrim_copy(std::string_view s) {
    std::string t(s);
    ltrim(t);
    return t;
}

// trim from end (copying)
static inline std::string rtrim_copy(std::string_view s) {
    std::string t(s);
    rtrim(t);
    return t;
}

// trim from both ends (copying)
static inline std::string trim_copy(std::string_view s) {
    std::string t(s);
    trim(t);
    return t;
}

cpp2: namespace = {

regex: namespace = {

view: <CharT> type == std::basic_string_view<CharT>;
bstring: <CharT> type == std::basic_string<CharT>;

list_end: type = {}

match_return: @struct type =
{
    matched: bool = false;
    length: size_t = 0;

    create: (m, l) -> match_return = {
      if m {
        return (true, l);
      }
      else {
        return (false, 0);
      }
    }
}

match_context: @struct <CharT, max_groups: size_t> type =
{

    groups: std::array<view<CharT>, max_groups>;

}

/*regular_expression: @interface <CharT> type = {

    match: <Ctx> (str: view<CharT>, inout ctx: Ctx) -> bool;
}*/

alternative_matcher_logic: <CharT, List ...> type = {
    match: (str: view<CharT>, inout ctx: _) -> _ = match_all<List...>(str, ctx);
    to_string: () -> _ = ((bstring<CharT>() + ... + ("|" + List::to_string()))).substr(1); // substr: Remove first '|'.

    private match_all: <First, Other ...> (str: view<CharT>, inout ctx: _) -> match_return = {
        r: match_return = First::match(str, ctx);

        if r.matched {
            return r;
        }
        else {
            if constexpr 0 != sizeof...(Other) {
                return match_all<Other...>(str.substr(r.length), ctx);
            }
            else {
                return (false, 0);
            }
        }
    }
}

any_matcher_logic: <CharT> type =
{
    match: (str: view<CharT>, inout ctx: _) -> match_return = match_return::create(!str.empty(), 1);
    to_string: () -> bstring<CharT> = bstring<CharT>(1, '.');
}

char_matcher_logic: <CharT, C: CharT> type =
{
    match: (str: view<CharT>, inout ctx: _) -> match_return = match_return::create(!str.empty() && str.front() == C, 1);
    to_string: () -> bstring<CharT> = bstring<CharT>(1, C);
}

empty_matcher_logic: <CharT> type =
{
    match: (str: view<CharT>, inout ctx: _) match_return(true, 0);
    to_string: () bstring<CharT>();
}

list_matcher_logic: <CharT, List ...> type =
{
    match: (str: view<CharT>, inout ctx: _) -> match_return = {
      return match_all<List...>(str, ctx);
    }

    to_string: () -> bstring<CharT> = {
      return (bstring<CharT>() + ... + List::to_string());
    }

    private match_all: <First, Other ...> (str: view<CharT>, inout ctx: _) -> match_return = {
      r: match_return = First::match(str, ctx);

      if r.matched {
        if constexpr 0 != sizeof...(Other) {
          o: match_return = match_all<Other...>(str.substr(r.length), ctx);

          if o.matched {
            r.length += o.length;
          }
          else {
            r = (false, 0);
          }
        }
      }

      return r;
    }
}

group_matcher_logic: <CharT, M, group: int> type = {
    match: (str: view<CharT>, inout ctx: _) -> match_return = {
        r: match_return = M::match(str, ctx);

        if r.matched {
            ctx.groups[group] = str.substr(0, r.length);
        }
        return r;
    }
    to_string: () -> bstring<CharT> = "((M::to_string())$)";
}

group_ref_matcher_logic: <CharT, group: int> type = {
    match: (str: view<CharT>, inout ctx: _) -> match_return =
        match_return::create(str.starts_with(ctx.groups[group]), ctx.groups[group].size());
    to_string: () -> bstring<CharT> = "\\((group)$)";
}

range_matcher_logic: <CharT, M, min_count: int, max_count: int> type = {

    // TODO: Add static assert on min_count and max_count.

    match: (str: view<CharT>, inout ctx: _) -> match_return = {
      r: match_return = (true, 0);
      o: match_return = (true, 0);

      count: int = -1; // First while is always true

      while (o.matched && count < max_count) next o = M::match(str.substr(r.length), ctx) {
        r.length += o.length;
        count += 1;
      }

      return match_return::create(count >= min_count, r.length);
    }
    to_string: () -> bstring<CharT> = {
      r: std::string = M::to_string();

      if min_count == max_count {
        r += "{(min_count)$}";
      }
      else if min_count == 0 {
        r += "{,(max_count)$}";
      }
      else if max_count == std::numeric_limits<int>::max() {
        r += "((min_count)$,}";
      }
      else {
        r += "{(min_count)$,(max_count)$}";
      }

      return r;
    }
}

special_range_matcher_logic: <CharT, M, min_count: int, max_count: int, symbol: CharT> type = {
    this: range_matcher_logic<CharT, M, min_count, max_count> = ();

    to_string: () -> bstring<CharT> = M::to_string() + symbol;
}

regex_parser_state: @struct type = {
    cur_match_list: std::vector<std::string> = ();
    alternate_match_lists: std::vector<std::vector<std::string>> = ();

    start_new_list: (inout this) = {
        new_list: std::vector<std::string> = ();
        std::swap(new_list, cur_match_list);
        alternate_match_lists.insert(alternate_match_lists.begin(), new_list);
    }

    swap: (inout this, inout t: regex_parser_state) = {
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
    }

    add: (inout this, matcher: _) = {
        cur_match_list.push_back(matcher);
    }

    wrap_last: (inout this, matcher) = {
        last: std::string = cur_match_list.back();
        cur_match_list.back() = matcher(last);
        _ = matcher;
        _ = last;
    }

    empty: (this) -> bool = cur_match_list.empty();
}


regex_parser: <Error_out> type = {

    regex: std::string_view;
    cur_state: regex_parser_state = ();
    pos: size_t = 0;

    named_groups: int = 1; // Global capture group.

    error_out: Error_out;

    operator=: (out this, r: std::string_view, e: Error_out) = {
        this.regex = r;
        this.error_out = e;
    }

    new_state: (inout this) -> regex_parser_state = {
        old_state: regex_parser_state = ();
        old_state.swap(cur_state);
        return old_state;
    }

    restore_state: (inout this, old_state: regex_parser_state) = {
        cur_state = old_state;
    }

    private create_matcher_from_list: (list: std::vector<std::string>) -> std::string = {
        if list.empty() { return "::cpp2::regex::empty_matcher_logic<char>"; }

        matcher: std::string = "::cpp2::regex::list_matcher_logic<char, ";

        seperator: std::string = "";
        for list do (cur) {
            matcher += seperator + cur;
            seperator = ", ";
        }
        matcher += ">";

        return matcher;
    }

    create_matcher_from_state: (this) -> std::string = {
        // Early out for no alternatives
        if 0 == cur_state.alternate_match_lists.size() { return create_matcher_from_list(cur_state.cur_match_list); }

        matcher: std::string = "::cpp2::regex::alternative_matcher_logic<char, ";

        seperator: std::string = "";
        add := :(list) = {
            matcher&$* += seperator&$* + create_matcher_from_list(list);
            seperator&$* = ", ";
        };
        if 0 != cur_state.cur_match_list.size() { add(cur_state.cur_match_list); }
        for cur_state.alternate_match_lists do (cur) {
            add(cur);
        }
        matcher += ">";

        return matcher;
    }

    error:(inout this, message: std::string) = {
        error_out("Error during parsing of regex '(regex)$' at position '(pos)$': (message)$");
    }

    is_alternative: (inout this, c: char) -> bool = {
        if c != '|' { return false; }

        cur_state.start_new_list();
        return true;
    }

    is_any: (inout this, c: char) -> bool = {
        if c == '.' {
            cur_state.add("::cpp2::regex::any_matcher_logic<char>");
            return true;
        }
        return false;
    }

    is_escape: (inout this, c: char) -> bool = {
        if c != '\\' { return false; }

        pos += 1;

        if pos >= regex.size() { error("Escape without a follwoing character."); }

        c_next: char = regex[pos];

        if '1' <= c_next <= '9' {
            group_id: int = c_next - '0';

            if group_id >= named_groups { error("Group reference is used before the group is declared."); }

            cur_state.add("::cpp2::regex::group_ref_matcher_logic<char, (group_id)$>");
        }
        else if std::string::npos != std::string("^.[]$()*{}?+|").find(c_next) {
            cur_state.add("::cpp2::regex::char_matcher_logic<char, '(c_next)$'>");
        }
        else if '\\' == c_next {
            cur_state.add("::cpp2::regex::char_matcher_logic<char, '\\\\'>");
        } else {
            error("Unkonwn escape.");
        }

        return true;
    }

    is_group: (inout this, c: char) -> bool = {
        if c != '(' { return false; }

        group_number := named_groups;
        named_groups += 1;

        old_state: _ = new_state();

        pos += 1;  // Skip the '('
        parse_until(')');

        inner:= create_matcher_from_state();
        restore_state(old_state);

        cur_state.add("::cpp2::regex::group_matcher_logic<char, (inner)$, (group_number)$>");

        return true;
    }

    is_handle_special: (inout this, c: char) -> bool = {
        if c == '\'' {
            cur_state.add("::cpp2::regex::char_matcher_logic<char, '\\(c)$'>");
            return true;
        }

        return false;
    }

    is_range: (inout this, c: char) -> bool = {

        if c != '{' { return false; }
        if cur_state.empty() { error("'{' without previous element."); }

        end: size_t = regex.find("}", pos);
        if end == std::string::npos { error("Missing closing bracket."); }

        inner: std::string = trim_copy(regex.substr(pos + 1, end - pos - 1));
        if inner.empty() { error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'"); }

        min_count: std::string = "0";
        max_count: std::string = "std::numeric_limits<int>::max()";

        sep: size_t = inner.find(",");
        if sep == std::string::npos {
            min_count = inner;
            max_count = inner;
        }
        else {
            inner_first: std::string = trim_copy(inner.substr(0, sep));
            inner_last: std::string = trim_copy(inner.substr(sep + 1));

            if (inner_first.empty() && inner_last.empty()) {
                error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'");
            }

            if !inner_first.empty() {
                min_count = inner_first;
            }
            if !inner_last.empty() {
                max_count = inner_last;
            }
        }

        // TODO: Check 0 <=n <= m
        cur_state.wrap_last( :(inner) -> _ == "::cpp2::regex::range_matcher_logic<char, (inner)$, (min_count$)$, (max_count$)$>");
        pos = end;

        return true;
    }

    is_special_range: (inout this, c: char) -> bool = {
        min_range: std::string = "0";
        max_range: std::string = "std::numeric_limits<int>::max()";
        if c == '*' {
            min_range = "0";
        }
        else if c == '+' {
            min_range = "1";
        }
        else if c == '?' {
            min_range = "0";
            max_range = "1";
        }
        else {
            return false;
        }

        if cur_state.empty() {
            error("'(c)$' without previous element.");
        }

        cur_state.wrap_last(:(inner) -> _ == "::cpp2::regex::special_range_matcher_logic<char, (inner)$, (min_range$)$, (max_range$)$, '(c$)$'>");
        return true;
    }

    parse_until:(inout this, term: char) = {
        while pos != regex.size() next pos += 1 {
            c: char = regex[pos];

            if c == term { return; }

            if is_any(c) { continue; }
            if is_range(c) { continue; }
            if is_special_range(c) { continue; }
            if is_group(c) { continue; }
            if is_escape(c) { continue; }
            if is_alternative(c) { continue; }
            if is_handle_special(c) { continue; }

            // No special char push a character match
            cur_state.add("::cpp2::regex::char_matcher_logic<char, '(c)$'>");
        }
    }

    parse:(inout this) -> std::string = {

        parse_until('\0');

        inner := create_matcher_from_state();
        return "::cpp2::regex::group_matcher_logic<char, (inner)$, 0>";
    }

}

generate_template: <Err> (regex: std::string_view, err: Err) -> std::string = {
    parser: regex_parser<Err> = (regex, err);
    r := parser.parse();
    _ = parser;
    return r;
}

}
}
