
//  Copyright (c) Herb Sutter
//  SPDX-License-Identifier: CC-BY-NC-ND-4.0

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#include <map>

cpp2: namespace = {

regex: namespace = {

greedy_alternative : bool == false;

bview: <CharT> type == std::basic_string_view<CharT>;
bstring: <CharT> type == std::basic_string<CharT>;

//-----------------------------------------------------------------------
//
//  Helper structures for the expression matching.
//
//-----------------------------------------------------------------------
//

expression_flags: type = {
    case_insensitive : int            ==  1;  // mod: i
    multiple_lines: int               ==  2;  // mod: m
    single_line: int                  ==  4;  // mod: s
    no_group_captures: int            ==  8;  // mod: n
    perl_code_syntax: int             == 16;  // mod: x
    perl_code_syntax_in_classes: int  == 32;  // mod: xx
}

// TODO: @enum as template parameter yields two error:
//     error: type 'range_flags' of non-type template parameter is not a structural type
//     error: non-type template parameter has incomplete type 'range_flags'
range_flags: type = {
    not_greedy: int == 1;
    greedy:     int == 2;
    possessive: int == 3;
}

match_group: @struct <Iter> type = {
    start: Iter = ();
    end: Iter = ();

    matched: bool = false;
}

match_return: @struct <Iter> type = {
    matched: bool = false;
    pos: Iter = ();
}

match_context: <CharT, Iter, max_groups: int, max_alternatives: int> type =
{
    public begin: Iter;
    public end: Iter;

    private groups: std::array<match_group<Iter>, max_groups> = ();
    private alternatives_pos: std::array<Iter, max_alternatives> = ();

    operator=: (out this, begin_: Iter, end_: Iter) = {
        begin = begin_;
        end = end_;
    }

    operator=: (out this, that) = {}

    // Getter and setter for groups
    //
    get_group: (in this, group) groups[group];

    get_group_string: (in this, group) -> std::string = {
        if group >= max_groups || !groups[group].matched {
            return "";
        }
        return std::string(groups[group].start, groups[group].end);
    }
    get_group_start:  (in this, group) -> int = {
        if group >= max_groups || !groups[group].matched {
            return 0;
        }
        return std::distance(begin, groups[group].start);
    }
    get_group_end:    (in this, group) -> int = {
        if group >= max_groups || !groups[group].matched {
            return 0;
        }
        return std::distance(begin, groups[group].end);
    }

    set_group_end: (inout this, group, pos) = {
        groups[group].end = pos;
        groups[group].matched = true;
    }

    set_group_invalid: (inout this, group) = {
        groups[group].matched = false;
    }

    set_group_start: (inout this, group, pos) = {
        groups[group].start = pos;
    }

    size: (in this) max_groups;

    // Getter and setter for alternatives

    get_alternative_pos: (in this, alternative) alternatives_pos[alternative];

    set_alternative_pos: (inout this, alternative, pos) = {
        alternatives_pos[alternative] = pos;
    }

    // Misc functions
    //
    print_ranges: (in this) -> bstring<CharT> = {
        r: bstring<CharT> = "";
        for groups do (cur) {
            if cur.matched {
                r += "((std::distance(begin, cur.start))$,(std::distance(begin, cur.end))$)";
            }
            else {
                r += "(?,?)";
            }
        }

        return r;
    }

    fail: (in this)            match_return(false, end);
    pass: (in this, cur: Iter) match_return(true, cur);

}

// Flag change for matching modifiers. Creates a new flag for match_modifiers.
// See expression_flags for possible flags.
//
match_modifiers_state_change: <has_change_: bool, reset_: bool, add_: int, remove_: int, str: fixed_string> type = {

    reset: bool == reset_;
    add: int == add_;
    remove: int == remove_;
    has_change: bool == has_change_;

    combine_inner: (old_flags: int) -> _ == {
        new_flags := old_flags;
        if reset {
            new_flags = 0;
        }
        new_flags = new_flags | add;
        new_flags = new_flags & (remove~);

        return new_flags;
    }

    to_string: () str.data();
}

match_modifiers_no_change : type == match_modifiers_state_change<false, false, 0, 0, "">;

// Current modifiers for the regular expression.
// See expression_flags for possible flags.
//
match_modifiers: @struct <flags_: int, Inner> type = {

    flags : int == flags_;

    // Push/pop management

    push: <Change>   (_ : Change) match_modifiers<Change::combine_inner(flags), match_modifiers<flags, Inner>>();
    pop:             ()           Inner();
    replace: <Change>(_ : Change) match_modifiers<Change::combine_inner(flags), Inner>();

    // Flag management
    //

    has_flag: (this, f: int) -> bool = {
        return  0 != (f & flags);
    }
}

//  Represents the remainder of the regular expression.
//
//  A matcher can ask this remainder if it would match. If yes a full match of the regular expression is found.
//  Otherwise the matcher can try a different alternative.
//
matcher_list: <CharT, List...> type = {
    match: (cur, inout ctx, modifiers, end_func) match_select<List...>(cur, ctx, modifiers, end_func);

    match: <OtherList...> (cur, inout ctx, modifiers, end_func, _: matcher_list<CharT, OtherList...>)
        match_select<List..., OtherList...>(cur, ctx, modifiers, end_func);

    private match_select: <First, Other...> (cur, inout ctx, modifiers, end_func)
        First::match(cur, ctx, modifiers, end_func, matcher_list<CharT, Other...>());
    private match_select: (cur, inout ctx, modifiers, end_func) end_func(cur, ctx, modifiers);

    reset_ranges: ( inout ctx) = (List::reset_ranges(ctx), ...);
    to_string: () (bstring<CharT>() + ... + List::to_string());

    prepend: <Pre> (_ : Pre) matcher_list<CharT, Pre, List...>();
}

no_tail: <CharT> type == matcher_list<CharT>;
true_end_func: @struct type = {
    operator(): (in this, cur, inout ctx, _) ctx.pass(cur);
}

//-----------------------------------------------------------------------
//
//  Character classes for regular expressions.
//
//-----------------------------------------------------------------------
//

// Class syntax: <any character> Example: a
//
single_class_entry: <CharT, C: CharT> type =
{
    includes: (c: CharT) c == C;
    to_string: ()        bstring<CharT>(1, C);
}

// Class syntax: - Example: a-c
//
range_class_entry: <CharT, Start: CharT, End: CharT> type =
{
    includes: (c: CharT) Start <= c <= End;
    to_string:        () "(Start)$-(End)$";
}

// Helper for combining two character classes
//
combined_class_entry: <CharT, List ...> type = {
    includes: (c: CharT) (false || ... || List::includes(c));
    to_string: ()        (bstring<CharT>() + ... + List::to_string());
}

// Class syntax: <list of characters>  Example: abcd
//
list_class_entry: <CharT, List ... : CharT> type = {
    includes: (c: CharT) (false || ... || (List == c));
    to_string: ()        (bstring<CharT>() + ... + List);
}

// Class syntax: [:<class name:]  Example: [:alnum:]
//
named_class_entry: <CharT, Name: fixed_string, Inner> type = {
    includes: (c: CharT) Inner::includes(c);
    to_string: ()        "[:(Name.data())$:]";
}

negated_class_entry: <CharT, Inner> type = {
    this: Inner = ();
    includes: (c: CharT) !Inner::includes(c);
}

// Short class syntax: \<character>  Example: \w
//
shorthand_class_entry: <CharT, Name: fixed_string, Inner> type = {
    includes: (c: CharT) Inner::includes(c);
    to_string: ()        Name.str();
}


// Named basic character classes
//
digits_class  : <CharT> type == named_class_entry<CharT, "digits", range_class_entry<CharT, '0', '9'>>;
lower_class   : <CharT> type == named_class_entry<CharT, "lower", range_class_entry<CharT, 'a', 'z'>>;
upper_class   : <CharT> type == named_class_entry<CharT, "upper", range_class_entry<CharT, 'A', 'Z'>>;

// Named other classes
//
alnum_class     : <CharT> type == named_class_entry<CharT, "alnum", combined_class_entry<CharT, lower_class<CharT>, upper_class<CharT>, digits_class<CharT>>>;
alpha_class     : <CharT> type == named_class_entry<CharT, "alpha", combined_class_entry<CharT, lower_class<CharT>, upper_class<CharT>>>;
ascii_class     : <CharT> type == named_class_entry<CharT, "ascii", range_class_entry<CharT, '\x00', '\x7F'>>;
blank_class     : <CharT> type == named_class_entry<CharT, "blank", list_class_entry<CharT, ' ', '\t'>>;
cntrl_class     : <CharT> type == named_class_entry<CharT, "cntrl", combined_class_entry<CharT, range_class_entry<CharT, '\x00', '\x1F'>, single_class_entry<CharT, '\x7F'>>>;
graph_class     : <CharT> type == named_class_entry<CharT, "graph", range_class_entry<CharT, '\x21', '\x7E'>>;
hor_space_class : <CharT> type == named_class_entry<CharT, "hspace", list_class_entry<CharT, '\t', ' '>>;
print_class     : <CharT> type == named_class_entry<CharT, "print", range_class_entry<CharT, '\x20', '\x7E'>>;
punct_class     : <CharT> type == named_class_entry<CharT, "punct", list_class_entry<CharT, '[','!','"','#','$','%','&','\'','(',')','*','+',',','-','.','/',':',';','<','=','>','?','@','[','\\',']','^','_','`','{','|','}','~',']'>>;
space_class     : <CharT> type == named_class_entry<CharT, "space", list_class_entry<CharT, ' ', '\t', '\r', '\n', '\v', '\f'>>;
ver_space_class : <CharT> type == named_class_entry<CharT, "vspace", list_class_entry<CharT, '\n', '\v', '\f', '\r'>>;
word_class      : <CharT> type == named_class_entry<CharT, "word", combined_class_entry<CharT, alnum_class<CharT>, single_class_entry<CharT, '_'>>>;
xdigit_class    : <CharT> type == named_class_entry<CharT, "xdigit", combined_class_entry<CharT, range_class_entry<CharT, 'A', 'F'>, range_class_entry<CharT, 'a', 'f'>, digits_class<CharT>>>;

// Shorthand class entries
//
short_digits_class     : <CharT> type == shorthand_class_entry<CharT, "\\d", digits_class<CharT>>;
short_hor_space_class  : <CharT> type == shorthand_class_entry<CharT, "\\h", hor_space_class<CharT>>;
short_space_class      : <CharT> type == shorthand_class_entry<CharT, "\\s", space_class<CharT>>;
short_vert_space_class : <CharT> type == shorthand_class_entry<CharT, "\\v", ver_space_class<CharT>>;
short_word_class       : <CharT> type == shorthand_class_entry<CharT, "\\w", word_class<CharT>>;


short_not_digits_class     : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\D", digits_class<CharT>>>;
short_not_hor_space_class  : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\H", hor_space_class<CharT>>>;
short_not_space_class      : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\S", space_class<CharT>>>;
short_not_vert_space_class : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\V", ver_space_class<CharT>>>;
short_not_word_class       : <CharT> type == negated_class_entry<CharT, shorthand_class_entry<CharT, "\\W", word_class<CharT>>>;

//-----------------------------------------------------------------------
//
//  Helper matchers for regular expressions.
//
//-----------------------------------------------------------------------
//

// Regex syntax: none Example: -
//
empty_matcher_logic: <CharT> type = {
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) Other::match(cur, ctx, modifiers, end_func);
    reset_ranges:  (_) = {}
    to_string:     ()  bstring<CharT>();
}


// Helper for greedy alternatives
//
extract_position_helper: <CharT, alternative: size_t> type = {
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        r := Other::match(cur, ctx, modifiers, end_func);
        if r.matched {
            ctx.set_alternative_pos(alternative, cur);
        }
        return r;
    }

    reset_ranges: (_) = {}
    to_string:    () bstring<CharT>();
}

// Helper for standard matchers with special syntax
//
//
special_syntax_wrapper: <CharT, syntax: fixed_string, base> type = {
    this : base = ();
    to_string:    () syntax.str();
}

//-----------------------------------------------------------------------
//
// Matchers and generators for regular expressions.
//
//-----------------------------------------------------------------------
//


no_reset: @struct type = {
    operator(): (this, inout _:) = {}
}

on_return: <Func> type = {

    func: Func;

    operator=: (out this, f: Func) = {
        func = f;
    }

    operator=: (move this) = {
        func();
    }
}

make_on_return: <Func> (func: Func) on_return<Func>(func);

regex_token: @polymorphic_base type = {

    public string_rep: std::string;

    operator=:(out this, str: std::string) = {
        string_rep = str;
    }

    operator=:(out this) = {
        string_rep = "";
    }

    //parse: (inout ctx: parse_context) -> token_ptr;
    generate_code: (virtual this, inout _: generation_context);

    get_groups: (virtual this) -> std::vector<int>;
    to_string: (this) -> std::string         = { return string_rep; }
    set_string: (inout this, s: std::string) = { string_rep = s; }
}

token_ptr : type == std::shared_ptr<regex_token>;
token_vec: type == std::vector<token_ptr>;

// State of the current group. See '(<pattern>)'
parse_context_group_state: @struct type = {

    // Current list of matchers
    cur_match_list: token_vec = ();

    // List of alternate matcher lists. E.g. ab|cd|xy
    alternate_match_lists: token_vec = ();

    //modifiers : parse_context_modifier_state = (); // TODO:

    next_alternative: (inout this) = {
        new_list: token_vec = ();
        std::swap(new_list, cur_match_list);
        _ = alternate_match_lists.insert(alternate_match_lists.end(), shared.new<regex_token_list>(new_list));
    }

    swap: (inout this, inout t: parse_context_group_state) = {
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
        //std::swap(modifiers, t.modifiers); // TODO:
    }

    get_tokens: (inout this) -> token_ptr = {
        if alternate_match_lists.empty() {
            return shared.new<regex_token_list>(cur_match_list);
        }
        else {
            next_alternative();
            return shared.new<alternative_token_gen>(alternate_match_lists);
        }
    }

    add: (inout this, token: token_ptr) = cur_match_list.push_back(token);

    empty: (this) -> bool = cur_match_list.empty();
}

parse_context: type = {
    regex: std::string_view;

    pos: size_t = 0;

    public error_text: std::string = "";

    public group_count: int = 1; // Root group.

    cur_group_state:        parse_context_group_state = ();

    next_group: (inout this) -> int = {
        id := group_count;
        group_count += 1;
        return id;
    }

    operator=:(out this, r: std::string_view) = {
        regex = r;
    }

    // State management functions
    //
    start_group: (inout this) -> parse_context_group_state = {
        old_state: parse_context_group_state = ();
        old_state.swap(cur_group_state);

        return old_state;
    }

    end_group: (inout this, old_state: parse_context_group_state) -> token_ptr = {
        inner := cur_group_state.get_tokens();
        cur_group_state = old_state;
        return inner;
    }

    next_alternative: (inout this) = {
        cur_group_state.next_alternative();
        //cur_branch_reset_state.next_alternative(); // TODO:
    }

    add_token: (inout this, token: token_ptr) = {
        cur_group_state.add(token);
    }

    has_token: (this) -> bool = {
        return !cur_group_state.empty();
    }

    pop_token: (inout this) -> token_ptr = {
        r : token_ptr = nullptr;
        if has_token() {
            r = cur_group_state.cur_match_list.back();
            cur_group_state.cur_match_list.pop_back();
        }

        return r;
    }

    get_tokens: (inout this) -> token_ptr = {
        return cur_group_state.get_tokens();
    }

    current: (this) -> char = { return regex[pos]; }

    has_next: (this) -> bool = { return pos < regex.size(); }
    next: (inout this) -> bool = {
        if has_next() {
            pos += 1; return true;
        }

        return false;
    }

    valid: (this) -> bool = { return has_next() && error_text.empty(); }

    error: (inout this, err: std::string) -> token_ptr = {
        error_text = err;
        return nullptr;
    }

    private get_next_position: (in this, in_class: bool, no_skip: bool) -> size_t = {
        perl_syntax := false;
        if !no_skip {
            // TODO:
            // if in_class {
            //     perl_syntax = cur_group_state.modifiers.perl_code_syntax && cur_group_state.modifiers.perl_code_syntax_in_classes;
            // }
            // else {
            //     perl_syntax = cur_group_state.modifiers.perl_code_syntax;
            // }
        }
        cur := pos + 1;
        if perl_syntax {
            while cur < regex.size() next (cur += 1) {
                n: = regex[cur];

                if space_class<char>::includes(n) {
                    continue;
                }
                else if !in_class && '#' == n {
                    cur = regex.find("\n", cur);
                    if std::string::npos == cur {
                        // No new line, comment runs until the end of the pattern
                        cur = regex.size();
                    }
                }
                else { // None space none comment char
                    break;
                }
            }
        }

        // Check for end of file.
        if cur > regex.size() {
            cur = regex.size();
        }
        return cur;
    }


    private grab_until_impl: (inout this, in e: std::string, out r: std::string, any: bool) -> bool = {
        start := pos;
        end:= pos;
        if any {
            end = regex.find_first_of(e, pos);
        }
        else {
            end = regex.find(e, pos);
        }

        if end != std::string_view::npos {
            r = regex.substr(start, end - pos);
            pos = end;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_until: (inout this, in e: std::string, out r: std::string)        grab_until_impl(e, out r, false);
    grab_until: (inout this, in e: char, out r: std::string)               grab_until_impl(std::string(1, e), out r, false);
    grab_until_one_of: (inout this, in e: std::string, out r: std::string) grab_until_impl(e, out r, true);

    private peek_impl: (in this, in_class: bool) -> char = {
        next_pos := get_next_position(in_class, false);
        if next_pos < regex.size() {
            return regex[next_pos];
        }
        else {
            return '\0';
        }
    }

    peek: (in this)          peek_impl(false);
    peek_in_class: (in this) peek_impl(true);

    parse_until:(inout this, term: char) -> bool = {
        cur_token: token_ptr = ();

        while valid() next _ = next() {
            if term == current() { break; }

            cur_token = nullptr;

            if !cur_token && valid() { cur_token = alternative_token::parse(this); }
            if !cur_token && valid() { cur_token = any_token::parse(this); }
            if !cur_token && valid() { cur_token = group_token::parse(this); }
            if !cur_token && valid() { cur_token = range_token::parse(this); }
            if !cur_token && valid() { cur_token = special_range_token::parse(this); }

            // Everything else is matched as it is.
            if !cur_token && valid() { cur_token = char_token::parse(this); }

            if cur_token && valid() {
                add_token(cur_token);
            } else {
                return false;
            }
        }

        return true;
    }

    parse: (inout this) parse_until('\0');


}

generation_function_context: @struct type = {
    code: std::string = "";
    tabs: std::string = "";

    add_tabs: (inout this, c: int) = {
        i: int = 0;
        while i < c next i += 1 {
            tabs += "  ";
        }
    }

    remove_tabs: (inout this, c: int) = {
        tabs = tabs.substr(0, c * 2);
    }
}

generation_context: type = {

    gen_stack: std::vector<generation_function_context> = (1);

    new_state : bool = true;
    matcher_func: int         = 0;
    reset_func:   int         = 0;
    temp_name:    int         = 0;
    entry_func:   std::string = "";

    match_parameters: (this) -> std::string = { return "r.pos, ctx, modifiers"; }

    add: (inout this, s: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$(s)$\n";
    }

    add_check: (inout this, check: std::string) = {
        cur := get_current();
        cur*.code += "(cur*.tabs)$if !cpp2::regex::(check)$ { r = ctx.fail(); return r; }\n";
    }

    add_statefull: (inout this, next_func: std::string, c: std::string) = {
        end_func_statefull(c);

        name := next_func.substr(0, next_func.ssize() - 2);
        start_func_named(name);
    }

    run: (inout this, token: token_ptr) -> std::string = {
        entry_func = generate_func(token);

        return get_base()*.code;
    }

    generate_func: (inout this, token: token_ptr) -> std::string = {
        name := start_func();
        token*.generate_code(this);
        end_func();

        return name;
    }

    generate_reset: (inout this, groups: std::vector<int>) -> std::string = {
        if groups.empty() {
            return "cpp2::regex::no_reset()";
        }

        name := gen_reset_func_name();
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): (this, inout ctx) = {\n";
        for groups do (g) {
            cur*.code += "(cur*.tabs)$  ctx.set_group_invalid((g)$);\n";
        }
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();

        return name + "()";
    }


    get_current: (inout this) -> *generation_function_context = {
        return gen_stack.back()&;
    }

    get_base: (inout this) -> *generation_function_context = {
        return gen_stack[0]&;
    }

    next_func_name: (inout this) -> std::string = {
        return gen_func_name() + "()";
    }

    protected start_func_named: (inout this, name: std::string) = {
        cur := new_context();

        cur*.code += "(cur*.tabs)$(name)$: @struct type = {\n";
        cur*.code += "(cur*.tabs)$  operator(): (this, cur, inout ctx, modifiers, other) -> _ = {\n";
        cur*.code += "(cur*.tabs)$    r := ctx.pass(cur);\n";
        cur*.add_tabs(2);
    }

    start_func: (inout this) -> std::string = {
        name := gen_func_name();
        start_func_named(name);
        return name + "()";
    }

    end_func_statefull: (inout this, s: std::string) = {
        cur := get_current();
        cur*.remove_tabs(2);
        cur*.code += "\n";
        cur*.code += "(cur*.tabs)$    r = (s)$;\n";
        cur*.code += "(cur*.tabs)$    return r;\n";
        cur*.code += "(cur*.tabs)$  }\n";
        cur*.code += "(cur*.tabs)$}\n";

        finish_context();
    }

    end_func: (inout this) = {
        end_func_statefull("other(r.pos, ctx, modifiers)");
    }

    get_entry_func: (this) -> std::string = {
        return entry_func;
    }

    protected gen_func_name: (inout this) -> std::string = {
        cur_id : = matcher_func;
        matcher_func += 1;
        return "func_(cur_id)$";
    }

    protected gen_reset_func_name: (inout this) -> std::string = {
        cur_id : = reset_func;
        reset_func += 1;
        return "reset_(cur_id)$";
    }

    gen_temp: (inout this) -> std::string = {
        cur_id := temp_name;
        temp_name += 1;
        return "tmp_(cur_id)$";
    }

    new_context: (inout this) -> *generation_function_context = {
        gen_stack.push_back(generation_function_context());
        cur := get_current();
        cur*.tabs = "    ";

        return cur;
    }

    finish_context: (inout this) = {
        cur := get_current();
        base := get_base();
        base*.code += cur*.code;

        gen_stack.pop_back();
    }
}

regex_token_list: @polymorphic_base type = {
    this: regex_token;

    public tokens: token_vec;

    operator=:(out this, t: token_vec) = {
        regex_token = (gen_string(t));
        tokens = t;
    }

    generate_code: (virtual this, inout ctx: generation_context) = {
        for tokens do (token) {
            token*.generate_code(ctx);
        }
    }

    get_groups: (virtual this) -> std::vector<int> = {
        r : std::vector<int> = ();
        for tokens do (token) {
            c := token*.get_groups();
            _ = r.insert(r.end(), c.begin(), c.end());
        }

        return r;
    }

    gen_string: (vec: token_vec) -> std::string = {
        r : std::string = "";
        for vec do (token) {
            r += token*.to_string();
        }
        return r;
    }
}


regex_token_base: @polymorphic_base type = {
    this: regex_token;

    operator=:(out this, str: std::string) = {
        regex_token = (str);
    }

    operator=:(out this) = {
        regex_token = ();
    }

    get_groups: (override this) -> std::vector<int> = { return (); }
}

//  Regex syntax: |  Example: ab|ba
//
//  Non greedy implementation. First alternative that matches is chosen.
//
alternative_token: @polymorphic_base type = {
    this: regex_token_base = ();

    operator=:(out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr = {
        if ctx.current() != '|' { return nullptr; }

        if !ctx.has_token() { return ctx.error("Alternative with no content."); }
        ctx.next_alternative();
        return shared.new<alternative_token>();
    }

    generate_code: (override this, inout _: generation_context) = {
        // No code gen here. alternative_token_gen is created in the parse_context
    }
}

alternative_token_gen: @polymorphic_base type = {
    this: regex_token;


    alternatives: token_vec;

    operator=: (out this, a: token_vec) = {
        regex_token = gen_string(a);
        alternatives = a;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        functions: std::string = "";

        i: int = 0;
        while i < alternatives.ssize() next i += 1 {
            functions += ", " + ctx.generate_func(alternatives[i]);
            functions += ", " + ctx.generate_reset(alternatives[i]*.get_groups());
        }

        next_name := ctx.next_func_name();

        ctx.add_statefull(next_name, "cpp2::regex::alternative_token_matcher<char>::match((ctx.match_parameters())$, other, (next_name)$ (functions)$)");
    }

    get_groups: (override this) -> std::vector<int> = {
        r: std::vector<int> = ();

        for alternatives do (cur) {
            t := cur*.get_groups();
            _ = r.insert(r.end(), t.begin(), t.end());
        }

        return r;
    }

    gen_string: (a: token_vec) -> std::string = {
        r: std::string = "";
        sep: std::string = "";

        for a do (cur) {
            r += sep + cur*.to_string();
            sep = "|";
        }

        return r;
    }
}

alternative_token_matcher: <CharT> type = {

    match: (cur, inout ctx, modifiers, end_func, tail, functions ...) -> _ = {
        return match_first(cur, ctx, modifiers, end_func, tail, functions...);
    }
    private match_first: <Other ...> (cur, inout ctx, modifiers, end_func, tail, cur_func, cur_reset, other ...: Other) -> _ = {
        inner_call := :(tail_cur, inout tail_ctx, tail_modifiers) -> _ == {
            return (tail)$(tail_cur, tail_ctx, tail_modifiers, (end_func)$);
        };
        r := cur_func(cur, ctx, modifiers, inner_call);
        if r.matched {
            return r;
        } else {
            cur_reset(ctx);

            if constexpr 0 != sizeof...(Other) {
                return match_first(cur, ctx, modifiers, end_func, tail, other...);
            } else {
                return ctx.fail();
            }
        }
    }
}

//  Regex syntax: .
//
any_token: @polymorphic_base type = {
    this: regex_token_base = (".");

    operator=:(out this) = {} // TODO: Base class constructor is ignored.

    parse: (inout ctx: parse_context) -> token_ptr = {
        if '.' != ctx.current() { return nullptr;}

        return shared.new<any_token>();
    }

    generate_code: (override this, inout ctx: generation_context) = {
        ctx.add_check("any_token_matcher<char>((ctx.match_parameters())$)");
    }
}

any_token_matcher: <CharT> (inout cur, inout ctx, modifiers) -> bool = {
    if cur != ctx.end // Any char except the end
        && (modifiers.has_flag(expression_flags::single_line) || cur* != '\n') { // Do not match new lines in multi line mode.
        cur += 1;
        return true;
    }
    else {
        return false;
    }
}

char_token: @polymorphic_base type = {
    this: regex_token_base;

    token: char;

    operator=: (out this, t: char) = {
        regex_token_base = (std::string(1, t));
        token = t;
    }

    parse: (inout ctx: parse_context) -> token_ptr = {
        return shared.new<char_token>(ctx.current());
    }

    generate_code: (override this, inout ctx: generation_context) = {
        upper: = safe_toupper(token);
        lower: = safe_tolower(token);
        ctx.add_check("char_token_matcher<char, '(token)$', '(lower)$', '(upper)$'>((ctx.match_parameters())$)");
    }
}

char_token_matcher: <CharT, C: CharT, L: CharT, U: CharT> (inout cur, inout ctx, modifiers) -> bool = {
    if modifiers.has_flag(expression_flags::case_insensitive) {
        if cur != ctx.end && (cur* == L || cur* == U) {
            cur += 1;
            return true;
        }
        else {
            return false;
        }
    }
    else {
        if cur != ctx.end && cur* == C {
            cur += 1;
            return true;
        }
        else {
            return false;
        }
    }
}

group_token: @polymorphic_base type = {
    this: regex_token = ();

    number: int      = -1;
    inner: token_ptr = nullptr;

    parse: (inout ctx: parse_context) -> token_ptr = {
        if ctx.current() != '(' { return nullptr; }

        if !ctx.next() { return ctx.error("No closing bracket for group."); }

        r := shared.new<group_token>();


        r*.number = ctx.next_group();

        old_state: _ = ctx.start_group();
        if !ctx.parse_until(')') { return nullptr; }
        r*.inner = ctx.end_group(old_state);
        r*.set_string("((r*.inner*.to_string())$)");

        return r;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        if -1 != number {
            ctx.add("ctx.set_group_start((number)$, r.pos);");
        }
        inner*.generate_code(ctx);
        if -1 != number {
            ctx.add("ctx.set_group_end((number)$, r.pos);");
            tmp_name := ctx.gen_temp();
            ctx.add("(tmp_name)$ :=  cpp2::regex::make_on_return(:() = {");
            ctx.add("  if !r&$*.matched {");
            ctx.add("    ctx&$*.set_group_invalid((number)$);");
            ctx.add("  }");
            ctx.add("});");
            ctx.add("_ = (tmp_name)$;"); // TODO: Guard object problem.
        }
    }

    get_groups: (override this) -> std::vector<int> = {
        if -1 == number {
            return ();
        }
        else {
            return (number);
        }
    }
}

// Regex syntax: <matcher>{min, max}  Example: a{2,4}
//
range_token: @polymorphic_base type = {
    this: regex_token = ("");

    protected min_count: int = -1;
    protected max_count: int = -1;
    protected kind:      int = range_flags::greedy;
    protected inner_token: token_ptr = nullptr;

    operator=: (out this) = {}

    parse: (inout ctx: parse_context) -> token_ptr = {
        r := shared.new<range_token>();
        if ctx.current() == '{' {
            if !ctx.has_token() { return ctx.error("'{' without previous element."); }

            inner: std::string = "";
            if !ctx.grab_until('}', out inner) { return ctx.error("Missing closing bracket '}'."); }

            inner = trim_copy(inner.substr(1)); // Remove '{' and white spaces.
            if inner.empty() { return ctx.error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'"); }

            // Non-greedy or possessive
            r*.parse_modifier(ctx);

            // Get range arguments
            min_count_str: std::string = "-1";
            max_count_str: std::string = "-1";

            sep: size_t = inner.find(",");
            if sep == std::string::npos {
                min_count_str = inner;
                max_count_str = inner;
                if !string_to_int(inner, r*.min_count) { return ctx.error("Could not convert range to number."); }
                r*.max_count = r*.min_count;
            }
            else {
                inner_first: std::string = trim_copy(inner.substr(0, sep));
                inner_last: std::string = trim_copy(inner.substr(sep + 1));

                if (inner_first.empty() && inner_last.empty()) {
                    return ctx.error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'");
                }

                if !inner_first.empty() {
                    min_count_str = inner_first;
                    if !string_to_int(inner_first, r*.min_count) { return ctx.error("Could not convert range to number."); }
                }
                if !inner_last.empty() {
                    max_count_str = inner_last;
                    if !string_to_int(inner_last, r*.max_count) { return ctx.error("Could not convert range to number."); }
                }
            }


            // Check validity of the range.
            if -1 != r*.min_count {
                if !(0 <= r*.min_count) {
                    return ctx.error("Min value in range is negative. Have (r*.min_count)$)");
                }
            }
            if -1 != r*.max_count {
                if !(0 <= r*.max_count) {
                    return ctx.error("Max value in range is negative. Have (r*.max_count)$)");
                }
                if -1 != r*.min_count {
                    if !(r*.min_count <= r*.max_count) {
                        return ctx.error("Min and max values in range are wrong it should hold 0 <= min <= max. Have 0 <= (r*.min_count)$ <= (r*.max_count)$");
                    }
                }
            }

            r*.inner_token = ctx.pop_token();
            r*.string_rep = r*.inner_token*.to_string() + r*.gen_range_string() + r*.gen_mod_string();

            return r;
        }

        return nullptr;
    }

    parse_modifier: (inout this, inout ctx: parse_context) = {
        if ctx.peek() == '?' {
            kind = range_flags::not_greedy;
            _ = ctx.next();
        }
        else if ctx.peek() == '+' {
            kind = range_flags::possessive;
            _ = ctx.next();
        }
    }

    gen_mod_string: (this) -> std::string = {
        if kind == range_flags::not_greedy {
            return "?";
        }
        else if kind == range_flags::possessive {
            return "+";
        }
        else {
            return "";
        }
    }

    gen_range_string: (this) -> std::string = {
        r : std::string = "";
        if min_count == max_count {
            r += "{(min_count)$}";
        }
        else if min_count == -1 {
            r += "{,(max_count)$}";
        }
        else if max_count == -1 {
            r += "{(min_count)$,}";
        }
        else {
            r += "{(min_count)$,(max_count)$}";
        }

        if kind == range_flags::not_greedy {
            r += "?";
        }
        else if kind == range_flags::possessive {
            r += "+";
        }
        return r;
    }

    generate_code: (override this, inout ctx: generation_context) = {
        inner_name := ctx.generate_func(inner_token);
        reset_name := ctx.generate_reset(inner_token*.get_groups());

        next_name := ctx.next_func_name();
        ctx.add_statefull(next_name, "cpp2::regex::range_token_matcher<char, (min_count)$, (max_count)$, (kind)$>::match((ctx.match_parameters())$, (inner_name)$, (reset_name)$, other, (next_name)$)");
    }

    get_groups: (override this) -> std::vector<int> = { return (); } // TODO: Implement
}

range_token_matcher: <CharT, min_count: int, max_count: int, kind: int> type = {

    match: <Iter> (cur: Iter, inout ctx, modifiers, inner, reset_func, end_func, tail) -> _ = {
        if range_flags::possessive == kind {
            return match_possessive(cur, ctx, modifiers, inner, end_func, tail);
        }
        else if range_flags::greedy == kind {
            return match_greedy(0, cur, ctx.end, ctx, modifiers, inner, reset_func, end_func, tail);
        }
        else { // range_flags::not_greedy == kind
            return match_not_greedy(cur, ctx, modifiers, inner, end_func, tail);
        }
    }

    private is_below_upper_bound: (count: int) -> bool = {
        if -1 == max_count { return true; }
        else { return count < max_count; }
    }

    private is_below_lower_bound: (count: int) -> bool = {
        if -1 == min_count { return false; }
        else { return count < min_count; }
    }

    private is_in_range: (count: int) -> bool = {
        if -1 != min_count && count < min_count { return false; }
        if -1 != max_count && count > max_count { return false; }
        return true;
    }

    private match_min_count: <Iter> (cur: Iter, inout ctx, modifiers, inner, end_func, inout count_r: int) -> _ = { // TODO: count_r as out parameter introduces a performance loss.
        res := ctx.pass(cur);
        count := 0;

        while is_below_lower_bound(count) && res.matched {
            res = inner(res.pos, ctx, modifiers, end_func);
            if res.matched {
                count += 1;
            }
        }

        count_r = count;
        return res;
    }

    private match_greedy: <Iter> (count: int, cur: Iter, last_valid: Iter, inout ctx, modifiers, inner, reset_func, end_func, other) -> match_return<Iter> = {
        inner_call := :(tail_cur, inout tail_ctx, _ /* ignore new modifiers */) -> _ == {
            return match_greedy((count + 1)$, tail_cur, (cur)$, tail_ctx, (modifiers)$, (inner)$, (reset_func)$, (end_func)$, (other)$);
        };
        is_m_valid := true;
        r := ctx.fail();
        if is_below_upper_bound(count) && (is_below_lower_bound(count) || cur != last_valid) {
            is_m_valid = false;  // Group ranges in M are invalidated through the call.
            r = inner(cur, ctx, modifiers, inner_call);
        }

        if !r.matched && is_in_range(count) {
            // The recursion did not yield a match try now the tail
            r = other(cur, ctx, modifiers, end_func);

            if r.matched && !is_m_valid{
                // We have a match rematch M if required
                reset_func(ctx);

                if count > 0 {
                    _ = inner(last_valid, ctx, modifiers, end_func);
                }
            }
        }

        return r;
    }

    private match_possessive: <Iter>(cur: Iter, inout ctx, modifiers, inner, end_func, other) -> match_return<Iter> = {
        count :=0;
        r := match_min_count(cur, ctx, modifiers, inner, end_func, count);

        if !r.matched {
          return r;
        }

        pos := r.pos;
        while r.matched && is_below_upper_bound(count) {
            r = inner(pos, ctx, modifiers, true_end_func());

            if pos == r.pos {
                break; // Break infinite loop.
            }
            if r.matched {
                count += 1;
                pos = r.pos;
            }
        }

        return other(pos, ctx, modifiers, end_func);
    }

    private match_not_greedy: <Iter> (cur: Iter, inout ctx, modifiers, inner, end_func, other) -> match_return<Iter> = {
        count := 0;
        start := match_min_count(cur, ctx, modifiers, inner, end_func, count);
        if !start.matched {
          return start;
        }

        pos := start.pos;
        while is_below_upper_bound(count) {
            o:= other(pos, ctx, modifiers, end_func);
            if o.matched {
                return o;
            }

            r:= inner(pos, ctx, modifiers, end_func);
            if !r.matched {
                return ctx.fail();
            }
            count += 1;
            pos = r.pos;
        }

        return other(pos, ctx, modifiers, end_func); // Upper bound reached.
    }
}

// Regex syntax: *, +, or ?  Example: aa*
//
special_range_token: @polymorphic_base type = {
    this : range_token = ();

    parse: (inout ctx: parse_context) -> token_ptr = {
        r := shared.new<special_range_token>();
        symbol: char = '\0';
        if ctx.current() == '*' {
            r*.min_count = 0;
            r*.max_count = -1;
            symbol = '*';
        }
        else if ctx.current() == '+' {
            r*.min_count = 1;
            r*.max_count = -1;
            symbol = '+';
        } else if ctx.current() == '?' {
            r*.min_count = 0;
            r*.max_count = 1;
            symbol = '?';
        } else {
            return nullptr;
        }

        if !ctx.has_token() { return ctx.error("'(ctx.current())$' without previous element."); }


        r*.parse_modifier(ctx);

        r*.inner_token = ctx.pop_token();
        r*.string_rep = r*.inner_token*.to_string() + symbol + r*.gen_mod_string();
        return r;
    }
}


//-----------------------------------------------------------------------
//
//  Matchers for regular expressions.
//
//-----------------------------------------------------------------------
//


// Regex syntax: none Example: -
//
branch_reset_matcher_logic: <CharT> type = {
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) Other::match(cur, ctx, modifiers, end_func);
    reset_ranges: (_) = {}
    to_string:    ()  bstring<CharT>("(?|");
}

// Regex syntax: <any character>  Example: a
//
char_matcher_logic: <CharT, C: CharT, L: CharT, U: CharT> type =
{
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        if modifiers.has_flag(expression_flags::case_insensitive) {
            if cur != ctx.end && (cur* == L || cur* == U) {
                return Other::match(cur + 1, ctx, modifiers, end_func);
            }
            else {
                return ctx.fail();
            }
        }
        else {
            if cur != ctx.end && cur* == C {
                return Other::match(cur + 1, ctx, modifiers, end_func);
            }
            else {
                return ctx.fail();
            }
        }

    }
    reset_ranges: (_) = {}
    to_string:    ()  bstring<CharT>(1, C);
}


// Regex syntax: [<character classes>]  Example: [abcx-y[:digits:]]
//
class_matcher_logic: <CharT, negate: bool, List ...> type =
{
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        if modifiers.has_flag(expression_flags::case_insensitive) {
            if cur != ctx.end && negate != ( match_any<List...>(safe_tolower(cur*)) || match_any<List...>(safe_toupper(cur*))) {
                return Other::match(cur + 1, ctx, modifiers, end_func);
            }
            else {
                return ctx.fail();
            }
        }
        else {
            if cur != ctx.end && negate != match_any<List...>(cur*) {
                return Other::match(cur + 1, ctx, modifiers, end_func);
            }
            else {
                return ctx.fail();
            }
        }
    }

    private match_any: <First, Other ...> (c: CharT) -> bool = {
        r: bool = First::includes(c);

        if !r {
            if constexpr 0 != sizeof...(Other) {
                r = match_any<Other...>(c);
            }
        }

        return r;
    }

    reset_ranges: (_) = {}

    to_string: () -> bstring<CharT> = {
        r: bstring<CharT> = "[";
        if negate {
            r += "^";
        }
        r += (bstring<CharT>() + ... + List::to_string());
        r += "]";

        return r;
    }
}

// Regex syntax: \K Example: \K
//
global_group_reset: <CharT> type = {
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        ctx.set_group_start(0, cur);
        return Other::match(cur, ctx, modifiers, end_func);
    }

    reset_ranges: (_) = {}
    to_string:    ()  bstring<CharT>("\\K");
}

// Regex syntax: (<inner>) Example: (.*)
//
group_matcher_start_logic: <CharT, group: int, ModifierChange, name: fixed_string, name_brackets: bool> type = {
    match: <Other, Modifiers> (cur, inout ctx, _ : Modifiers, end_func, _ : Other) -> _ = {
        if -1 != group {
            ctx.set_group_start(group, cur);
        }
        return Other::match(cur, ctx, Modifiers::push(ModifierChange()), end_func);
    }

    reset_ranges: (inout ctx) = {
        if -1 != group {
            ctx.set_group_invalid(group);
        }
    }

    to_string: () -> bstring<CharT> = {
        if group != 0 {
            if 0 != name.size() {
                if name_brackets {
                    return "(?<(name.data())$>";
                }
                else {
                    return "(?'(name.data())$'";
                }
            }
            else if ModifierChange::has_change {
                return "(?(ModifierChange::to_string())$:";
            }
            else {
                return "(";
            }
        }
        else {
            return "";
        }
    }
}

group_matcher_end_logic: <CharT, group: int> type = {
    match: <Other, Modifier> (cur, inout ctx, _: Modifier, end_func, _ : Other) -> _ = {
        if -1 != group {
            ctx.set_group_end(group, cur);
        }
        r := Other::match(cur, ctx, Modifier::pop(), end_func);
        if !r.matched && -1 != group {
            ctx.set_group_invalid(group);
        }
        return r;
    }

    reset_ranges: (_) = {}

    to_string: () -> bstring<CharT> = {
        if group != 0 {
            return ")";
        }
        else {
            return "";
        }
    }
}

special_group_end_logic: <CharT> type = {
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) Other::match(cur, ctx, modifiers, end_func);
    reset_ranges: (_) = {}
    to_string:    ()  bstring<CharT>(")");
}

// Regex syntax: \<number>  Example: \1
//
group_ref_matcher_logic: <CharT, group: int, symbol: fixed_string> type = {
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        g := ctx.get_group(group);

        pos := cur;
        group_pos := g.start;
        while group_pos != g.end && pos != ctx.end next (group_pos++, pos++) {
            if modifiers.has_flag(expression_flags::case_insensitive) {
                if safe_tolower(group_pos*) != safe_tolower(pos*) {
                    return ctx.fail();
                }
            }
            else {
                if group_pos* != pos* {
                    return ctx.fail();
                }
            }
        }

        if group_pos == g.end {
            return Other::match(pos, ctx, modifiers, end_func);
        }
        else {
            return ctx.fail();
        }

    }
    reset_ranges: (_) = {}
    to_string:    ()  symbol.str();
}

// Regex syntax: $  Example: aa$
//
line_end_matcher_logic: <CharT, match_new_line: bool, match_new_line_before_end: bool> type =
{
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        if cur == ctx.end || (match_new_line && modifiers.has_flag(expression_flags::multiple_lines) && cur* == '\n') {
            return Other::match(cur, ctx, modifiers, end_func);
        }
        else if match_new_line_before_end && (cur* == '\n' && (cur + 1) == ctx.end) { // Special case for new line at end.
            return Other::match(cur, ctx, modifiers, end_func);
        }
        else {
            return ctx.fail();
        }
    }

    reset_ranges: (_) = {}
    to_string:    ()  bstring<CharT>("\\$");
}

// Regex syntax: ^  Example: ^aa
//
line_start_matcher_logic: <CharT, match_new_line: bool> type =
{
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        if cur == ctx.begin || (match_new_line && modifiers.has_flag(expression_flags::multiple_lines)  && (cur - 1)* == '\n') {
            return Other::match(cur, ctx, modifiers, end_func);
        }
        else {
            return ctx.fail();
        }

    }
    reset_ranges: (_) = {}
    to_string:    ()  bstring<CharT>(1, '^');
}

// Regex syntax: (?=) or (?!) or (*pla), etc.  Example: (?=AA)
//
lookahead_matcher_logic: <CharT, positive: bool, name: fixed_string, Pattern> type =
{
    match: <Other> (cur, inout ctx, modifiers, end_func, _ : Other) -> _ = {
        r := Pattern::match(cur, ctx, modifiers, true_end_func(), no_tail<CharT>());

        if !positive {
            r.matched = !r.matched;
        }

        if r.matched {
            return Other::match(cur, ctx, modifiers, end_func);
        }
        else {
            return ctx.fail();
        }

    }
    reset_ranges: (inout ctx) = { Pattern::reset_ranges(ctx); }
    to_string:    ()          "((name.data())$(Pattern::to_string())$)";
}

// Regex syntax: (?<modifiers>)  Example: (?i)
//
modifier_matcher_logic: <CharT, ModifierChange> type =
{
    match: <Other, Modifier> (cur, inout ctx, _: Modifier, end_func, _ : Other) -> _ = {
        return Other::match(cur, ctx, Modifier::replace(ModifierChange()), end_func);
    }
    reset_ranges: (_) = {}
    to_string:    ()  "(?(ModifierChange::to_string())$)";
}

// Named character classes
//

named_class_matcher_logic: <CharT, Name: fixed_string, negate: bool, List ...> type =  {
    this: special_syntax_wrapper<CharT, Name, class_matcher_logic<CharT, negate, List...>> = ();
}

named_class_no_new_line: <CharT> type == named_class_matcher_logic<CharT, "\\\\N", true, single_class_entry<CharT, '\n'>>; // TODO: Remove second \, switch to raw strings.
named_class_digits     : <CharT> type == named_class_matcher_logic<CharT, "\\d", false, digits_class<CharT>>;
named_class_hor_space  : <CharT> type == named_class_matcher_logic<CharT, "\\h", false, hor_space_class<CharT>>;
named_class_space      : <CharT> type == named_class_matcher_logic<CharT, "\\s", false, space_class<CharT>>;
named_class_ver_space  : <CharT> type == named_class_matcher_logic<CharT, "\\v", false, ver_space_class<CharT>>;
named_class_word       : <CharT> type == named_class_matcher_logic<CharT, "\\w", false, word_class<CharT>>;


named_class_not_digits    : <CharT> type == named_class_matcher_logic<CharT, "\\D", true, digits_class<CharT>>;
named_class_not_hor_space : <CharT> type == named_class_matcher_logic<CharT, "\\H", true, hor_space_class<CharT>>;
named_class_not_space     : <CharT> type == named_class_matcher_logic<CharT, "\\S", true, space_class<CharT>>;
named_class_not_ver_space : <CharT> type == named_class_matcher_logic<CharT, "\\V", true, ver_space_class<CharT>>;
named_class_not_word      : <CharT> type == named_class_matcher_logic<CharT, "\\W", true, word_class<CharT>>;

// Other named matchers
named_string_end_or_before_new_line_at_end: <CharT> type  == special_syntax_wrapper<CharT, "\\Z", line_end_matcher_logic<CharT, false, true>>;
named_string_end: <CharT> type   == special_syntax_wrapper<CharT, "\\z", line_end_matcher_logic<CharT, false, false>>;
named_string_start: <CharT> type == special_syntax_wrapper<CharT, "\\A", line_start_matcher_logic<CharT, false>>;

// Regex syntax: \b or \B  Example: \bword\b
//
// Matches the start end end of word boundaries.
//
word_boundary_matcher_logic: <CharT, negate: bool> type =
{
    match: <Other> (cur, inout ctx, modifiers, end_func, _: Other) -> _ = {
        words : word_class<CharT> = ();
        is_match := false;
        if cur == ctx.begin { // String start
            if cur != ctx.end { // No empty string
                is_match = words.includes(cur*);
            }
        }
        else if cur == ctx.end { // String end
            is_match = words.includes((cur - 1)*);
        }
        else { // Middle of string
            is_match =
                   (words.includes((cur - 1)*) && !words.includes(cur*))  // End of word: \w\W
                || (!words.includes((cur - 1)*) && words.includes(cur*)); // Start of word: \W\w

        }
        if negate {
            is_match = !is_match;
        }

        if is_match{
            return Other::match(cur, ctx, modifiers, end_func);
        }
        else {
            return ctx.fail();
        }

    }
    reset_ranges: (_) = {}
    to_string:    () -> bstring<CharT> = {
        if negate {
            return "\\B";
        } else {
            return "\\b";
        }
    }
}


//-----------------------------------------------------------------------
//
//  Regular expression implementation.
//
//-----------------------------------------------------------------------
//

// Helper for named groups.

group_name_list: <name: fixed_string, group_id: int, Inner> type = {

    get_group_id: (g) -> int = {
        if g == name.str() {
            return group_id;
        }
        else {
            return Inner::get_group_id(g);
        }
    }
}

group_name_list_end: type = {
    get_group_id: (_) -1;
}

// Regular expression implementation
regular_expression: <CharT, flags: int, groups: size_t, alternatives: size_t, named_groups, Matcher> type = {

    context: <Iter> type == match_context<CharT, Iter, groups, alternatives>;
    modifiers: type      == match_modifiers<flags, int>;

    // TODO: Named multiple return has problems with templates.
    search_return: <Iter> type = {
        public matched: bool;
        public ctx: context<Iter>;

        operator=:(out this, matched_: bool, ctx_: context<Iter>) = {
            matched = matched_;
            ctx = ctx_;
        }

        group_number: (this) ctx.size();
        group:        (this, g: int) ctx.get_group_string(g);
        group_start:  (this, g: int) ctx.get_group_start(g);
        group_end:    (this, g: int) ctx.get_group_end(g);

        group:        (this, g: bstring<CharT>) group(get_group_id(g));
        group_start:  (this, g: bstring<CharT>) group_start(get_group_id(g));
        group_end:    (this, g: bstring<CharT>) group_end(get_group_id(g));

        private get_group_id: (this, g: bstring<CharT>) -> _ = {
            group_id := named_groups::get_group_id(g);
            if -1 == group_id {
                // TODO: Throw error.
            }
            return group_id;
        }
    }

    match: (in this, str: bview<CharT>)                 match(str.begin(), str.end());
    match: (in this, str: bview<CharT>, start)          match(get_iter(str, start), str.end());
    match: (in this, str: bview<CharT>, start, length)  match(get_iter(str, start), get_iter(str, start + length));
    match: <Iter> (in this, start: Iter, end: Iter) -> search_return<Iter> = {
        ctx: context = (start, end);

        r := Matcher::match(start, ctx, modifiers(), true_end_func());
        return search_return(r.matched && r.pos == end, ctx);
    }

    search: (in this, str: bview<CharT>)                 search(str.begin(), str.end());
    search: (in this, str: bview<CharT>, start)          search(get_iter(str, start), str.end());
    search: (in this, str: bview<CharT>, start, length)  search(get_iter(str, start), get_iter(str, start + length));
    search: <Iter> (in this, start: Iter, end: Iter) -> search_return<Iter> = {
        matched := false;
        ctx: context = (start, end);

        cur:= start;
        while true next (cur++) {
            if Matcher::match(cur, ctx, modifiers(), true_end_func()).matched {
                matched = true;
                break;
            }

            if cur == ctx.end {
                break;
            }
        }

        return search_return(matched, ctx);
    }

    to_string: (in this) Matcher::to_string();

    // Helper functions
    //

    private get_iter: (str: bview<CharT>, pos) -> _ = {
        if pos < str.size() {
            return str.begin() + pos;
        }
        else {
            return str.end();
        }
    }
}

// Regular expression implementation
regular_expression_with_matcher: <CharT, Matcher> type = {

    context: <Iter> type == match_context<CharT, Iter, Matcher::group_count::value, 0>;
    modifiers: type      == match_modifiers<Matcher::initial_flags::value, int>;

    // TODO: Named multiple return has problems with templates.
    search_return: <Iter> type = {
        public matched: bool;
        public ctx: context<Iter>;

        operator=:(out this, matched_: bool, ctx_: context<Iter>) = {
            matched = matched_;
            ctx = ctx_;
        }

        group_number: (this) ctx.size();
        group:        (this, g: int) ctx.get_group_string(g);
        group_start:  (this, g: int) ctx.get_group_start(g);
        group_end:    (this, g: int) ctx.get_group_end(g);

        group:        (this, g: bstring<CharT>) group(get_group_id(g));
        group_start:  (this, g: bstring<CharT>) group_start(get_group_id(g));
        group_end:    (this, g: bstring<CharT>) group_end(get_group_id(g));

        private get_group_id: (this, g: bstring<CharT>) -> _ = {
            group_id := Matcher::get_named_group_index(g);
            if -1 == group_id {
                // TODO: Throw error.
            }
            return group_id;
        }
    }

    match: (in this, str: bview<CharT>)                 match(str.begin(), str.end());
    match: (in this, str: bview<CharT>, start)          match(get_iter(str, start), str.end());
    match: (in this, str: bview<CharT>, start, length)  match(get_iter(str, start), get_iter(str, start + length));
    match: <Iter> (in this, start: Iter, end: Iter) -> search_return<Iter> = {
        ctx: context = (start, end);

        r := Matcher::entry(start, ctx, modifiers());
        return search_return(r.matched && r.pos == end, ctx);
    }

    search: (in this, str: bview<CharT>)                 search(str.begin(), str.end());
    search: (in this, str: bview<CharT>, start)          search(get_iter(str, start), str.end());
    search: (in this, str: bview<CharT>, start, length)  search(get_iter(str, start), get_iter(str, start + length));
    search: <Iter> (in this, start: Iter, end: Iter) -> search_return<Iter> = {
        matched := false;
        ctx: context = (start, end);

        cur:= start;
        while true next (cur++) {
            if Matcher::entry(cur, ctx, modifiers()).matched {
                matched = true;
                break;
            }

            if cur == ctx.end {
                break;
            }
        }

        return search_return(matched, ctx);
    }

    to_string: (in this) Matcher::to_string();

    // Helper functions
    //

    private get_iter: (str: bview<CharT>, pos) -> _ = {
        if pos < str.size() {
            return str.begin() + pos;
        }
        else {
            return str.end();
        }
    }
}

//-----------------------------------------------------------------------
//
//  Parser for regular expression.
//
//-----------------------------------------------------------------------
//

// State of the expression modifiers.
//
regex_parser_modifier_state: @struct type = {
    group_captures_have_numbers : bool = true;
    perl_code_syntax:             bool = false;
    perl_code_syntax_in_classes:  bool = false;
}

// State of the current group. See '(<pattern>)'
regex_parser_group_state: @struct type = {

    // Current list of matchers
    cur_match_list: std::vector<std::string> = ();

    // List of alternate matcher lists. E.g. ab|cd|xy
    alternate_match_lists: std::vector<std::vector<std::string>> = ();

    modifiers : regex_parser_modifier_state = ();

    next_alternative: (inout this) = {
        new_list: std::vector<std::string> = ();
        std::swap(new_list, cur_match_list);
        _ = alternate_match_lists.insert(alternate_match_lists.end(), new_list);
    }

    swap: (inout this, inout t: regex_parser_group_state) = {
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
        std::swap(modifiers, t.modifiers);
    }

    add: (inout this, matcher: _) = cur_match_list.push_back(matcher);

    wrap_last: (inout this, matcher) = {
        last:= cur_match_list.back();
        cur_match_list.back() = matcher(last);
        _ = matcher;
        _ = last;
    }

    empty: (this) -> bool = cur_match_list.empty();
}

// State for the branch reset. Takes care of the group numbering. See '(|<pattern>)'.
regex_branch_reset_state: @struct type = {
    is_active : bool = false;
    cur_group : int  = 1; // Global capture group.
    max_group : int  = 1;
    from      : int  = 1;

    next: (inout this) -> int = {
        g := cur_group;
        cur_group += 1;
        max_group = max(max_group, cur_group);

        return g;
    }

    set_next: (inout this, g: int) = {
        cur_group = g;
        max_group = max(max_group, g);
    }

    next_alternative: (inout this) = {
        if is_active {
            cur_group = from;
        }
    }
}

// Parser and generator for regular expressions.
regex_parser: <Error_out> type = {

    regex:     std::string_view;
    modifier:  std::string_view;
    error_out: Error_out;

    cur_group_state:        regex_parser_group_state = ();
    cur_branch_reset_state: regex_branch_reset_state = ();
    pos:                    size_t = 0;
    alternatives_count:     int = 0;
    named_groups :          std::map<std::string, int> = ();
    has_error:              bool = false;

    source: std::string = "";

    supported_classes: std::vector<std::string> = ("alnum", "alpha", "ascii", "blank", "cntrl", "digits", "graph",
                                                   "lower", "print", "punct", "space", "upper", "word", "xdigit");

    operator=: (out this, r: std::string_view, m: std::string_view, e: Error_out) = {
        this.regex = r;
        this.modifier = m;
        this.error_out = e;
    }

    // State management functions
    //
    group_new_state: (inout this) -> regex_parser_group_state = {
        old_state: regex_parser_group_state = ();
        old_state.swap(cur_group_state);

        return old_state;
    }

    group_restore_state: (inout this, old_state: regex_parser_group_state) = {
        cur_group_state = old_state;
    }

    // Branch reset management functions
    //

    branch_reset_new_state: (inout this) -> regex_branch_reset_state = {
        old_state: regex_branch_reset_state = ();
        std::swap(old_state, cur_branch_reset_state);

        cur_branch_reset_state.is_active = true;
        cur_branch_reset_state.cur_group = old_state.cur_group;
        cur_branch_reset_state.from      = cur_branch_reset_state.cur_group;
        cur_branch_reset_state.max_group = cur_branch_reset_state.cur_group;

        return old_state;
    }

    branch_reset_restore_state: (inout this, old_state: regex_branch_reset_state) = {
        next_group := cur_branch_reset_state.max_group;
        cur_branch_reset_state = old_state;
        cur_branch_reset_state.set_next(next_group);
    }

    // Position management functions
    //

    private get_next_position: (in this, in_class: bool, no_skip: bool) -> size_t = {
        perl_syntax := false;
        if !no_skip {
            if in_class {
                perl_syntax = cur_group_state.modifiers.perl_code_syntax && cur_group_state.modifiers.perl_code_syntax_in_classes;
            }
            else {
                perl_syntax = cur_group_state.modifiers.perl_code_syntax;
            }
        }
        cur := pos + 1;
        if perl_syntax {
            while cur < regex.size() next (cur += 1) {
                n: = regex[cur];

                if space_class<char>::includes(n) {
                    continue;
                }
                else if !in_class && '#' == n {
                    cur = regex.find("\n", cur);
                    if std::string::npos == cur {
                        // No new line, comment runs until the end of the pattern
                        cur = regex.size();
                    }
                }
                else { // None space none comment char
                    break;
                }
            }
        }

        // Check for end of file.
        if cur > regex.size() {
            cur = regex.size();
        }
        return cur;
    }

    private next_impl: (inout this, out n: char, in_class: bool, no_skip: bool) -> bool = {
        pos = get_next_position(in_class, no_skip);
        if pos != regex.size() {
            n = regex[pos];
            return true;
        }
        else {
            n = '\0';
            return false;
        }
    }

    next: (inout this, out n: char)          next_impl(out n, false, false);
    next_in_class: (inout this, out n: char) next_impl(out n, true, false);
    next_no_skip: (inout this, out n: char)  next_impl(out n, false, true);



    skip: (inout this) -> bool = {
        c: char;
        r := next(out c);
        _ = c;
        return r;
    }

    skip_n:(inout this, n: int) -> bool = {
        r := true;
        cur := 0;
        while r && cur < n next (r = skip()) {
            cur += 1;
        }
        return r;
    }

    current: (in this) -> char = {
        if pos < regex.size() {
            return regex[pos];
        } else {
            return '\0';
        }
    }

    private peek_impl: (in this, in_class: bool) -> char = {
        next_pos := get_next_position(in_class, false);
        if next_pos < regex.size() {
            return regex[next_pos];
        }
        else {
            return '\0';
        }
    }

    peek: (in this)          peek_impl(false);
    peek_in_class: (in this) peek_impl(true);

    private grab_until_impl: (inout this, in e: std::string, out r: std::string, any: bool) -> bool = {
        start := pos;
        end:= pos;
        if any {
            end = regex.find_first_of(e, pos);
        }
        else {
            end = regex.find(e, pos);
        }

        if end != std::string_view::npos {
            r = regex.substr(start, end - pos);
            pos = end;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_until: (inout this, in e: std::string, out r: std::string)        grab_until_impl(e, out r, false);
    grab_until: (inout this, in e: char, out r: std::string)               grab_until_impl(std::string(1, e), out r, false);
    grab_until_one_of: (inout this, in e: std::string, out r: std::string) grab_until_impl(e, out r, true);

    grab_n: (inout this, in n: int, out r: std::string) -> bool = {
        if pos + n <= regex.size() {
            r = regex.substr(pos, n);
            pos += n - 1;
            return true;
        }
        else {
            r = "";
            return false;
        }
    }

    grab_number: (inout this) -> std::string = {
        start := pos;
        start_search := pos;
        if regex[start_search] == '-' {
            start_search += 1;
        }
        end := regex.find_first_not_of("1234567890", start_search);

        r : std::string;
        if end != std::string::npos {
            r = regex.substr(start, end - start);
            pos = end - 1;
        }
        else {
            r = regex.substr(start);
            pos = regex.size() - 1;
        }
        return r;
    }

    // Misc functions
    //
    error:(inout this, message: std::string) = {
        error_out("Error during parsing of regex '(regex)$' at position '(pos)$': (message)$");
        has_error = true;
    }

    join: (list, func) -> std::string = {
        r: std::string = "";

        separator: std::string = "";
        for list do (cur) {
            r += separator + func(cur);
            separator = ", ";
        }

        return r;
    }

    join: (list: std::vector<std::string>) join(list, :(arg) -> _ == arg); // Todo: Shorthand syntax for const lambda


    // Creator functions for matchers.
    //

    create_matcher: (in this, name: std::string, template_arguments: std::string) -> _ = {
        sep := ", ";
        if template_arguments.empty() { sep = ""; }

        return "::cpp2::regex::(name)$<char(sep)$(template_arguments)$>";
    }

    create_matcher_from_list: (inout this, list) create_matcher("matcher_list", join(list));

    create_matcher_from_state: (inout this) -> std::string = {
        if 0 == cur_group_state.alternate_match_lists.size() { return create_matcher_from_list(cur_group_state.cur_match_list); }

        if 0 == cur_group_state.cur_match_list.size() {
            cur_group_state.add(create_matcher("empty_matcher_logic", ""));
        }
        cur_group_state.next_alternative();
        cur_branch_reset_state.next_alternative();

        list := join(cur_group_state.alternate_match_lists, :(arg) -> _ == create_matcher_from_list(arg));
        alternative_id := alternatives_count;
        alternatives_count += 1;

        return create_matcher("alternative_matcher_logic", "(alternative_id)$, (list)$");
    }

    create_named_groups_list: (in this) -> std::string = {
        r : std::string = "::cpp2::regex::group_name_list_end";

        for named_groups do (cur) {
            r = "::cpp2::regex::group_name_list<\"(cur.first)$\", (cur.second)$, (r)$>";
        }

        return r;
    }

    // Parser helper functions.

    parse_lookahead: (inout this, name: std::string, positive: bool) -> bool = {
        old_state: _ = group_new_state();
        parse_until(')');
        inner:= create_matcher_from_state();
        group_restore_state(old_state);

        cur_group_state.add(create_matcher("lookahead_matcher_logic", "(positive)$, \"(name)$\", (inner)$"));

        return true;
    }

    parser_expression_modifiers: (inout this) -> std::string = {
        r: std::string = "0";
        sep: std::string = " | ";

        add := :(name, inout r) = {
            r += "(sep$)$(name)$";
        };

        mod_pos := 0;
        while mod_pos < modifier.ssize() next mod_pos += 1 {
            c: char = modifier[mod_pos];

            if      c == 'i' { add("::cpp2::regex::expression_flags::case_insensitive", r); }
            else if c == 'm' { add("::cpp2::regex::expression_flags::multiple_lines", r); }
            else if c == 's' { add("::cpp2::regex::expression_flags::single_line", r); }
            else if c == 'n' {
                add("::cpp2::regex::expression_flags::no_group_captures", r);
                cur_group_state.modifiers.group_captures_have_numbers = false;
            }
            else if c == 'x' {
                add("::cpp2::regex::expression_flags::perl_code_syntax", r);
                cur_group_state.modifiers.perl_code_syntax = true;

                // Check if we have 'xx'
                mod_pos += 1;
                if mod_pos < modifier.ssize() && 'x' == modifier[mod_pos] {
                    add("::cpp2::regex::expression_flags::perl_code_syntax_in_classes", r);
                    cur_group_state.modifiers.perl_code_syntax_in_classes = true;
                }
            }
            else { error("Unknown modifier: '(c)$'"); }
        }

        return r;
    }

    parser_group_modifiers: (inout this, change_str: std::string, out modifier_change: std::string,
                      inout parser_modifiers: regex_parser_modifier_state) -> bool = {
        is_negative := false;
        is_reset    := false;

        add    := 0;
        remove := 0;

        apply := :(flag: int) = {
            if is_negative&$* {
                remove&$* |= flag;
            }
            else {
                add&$* |= flag;
            }
        };

        iter := change_str.begin();
        while iter != change_str.end() next (iter++) {
            cur := iter*;
            if cur == '^' {
                is_reset = true;
            }
            else if cur == '-' {
                if is_reset { error("No negative modifier allowed."); return false; }
                is_negative = true;
            }
            else if cur == 'i' { apply(expression_flags::case_insensitive); }
            else if cur == 'm' { apply(expression_flags::multiple_lines); }
            else if cur == 's' { apply(expression_flags::single_line); }
            else if cur == 'n' {
                apply(expression_flags::no_group_captures);
                parser_modifiers.group_captures_have_numbers = is_negative;
            }
            else if cur == 'x' {
                if (iter + 1) == change_str.end() || (iter + 1)* != 'x' {
                    // x modifier
                    apply(expression_flags::perl_code_syntax);
                    parser_modifiers.perl_code_syntax = !is_negative;

                    // Just x unsets xx and remove x also removes xx
                    remove |= expression_flags::perl_code_syntax_in_classes;
                    parser_modifiers.perl_code_syntax_in_classes = false;
                }
                else { // xx modifier
                    // xx also sets or unsets x
                    apply(expression_flags::perl_code_syntax);
                    parser_modifiers.perl_code_syntax = !is_negative;

                    apply(expression_flags::perl_code_syntax_in_classes);
                    parser_modifiers.perl_code_syntax_in_classes = !is_negative;

                    iter++; // Skip the second x
                }
            }
            else {
                error("Unknown modifier: (cur)$"); return false;
            }
        }

        modifier_change = "::cpp2::regex::match_modifiers_state_change<true, (is_reset)$, (add)$, (remove)$, \"(change_str)$\">";

        return true;
    }

    // Parsing functions
    //

    is_alternative: (inout this, c: char) -> bool = {
        if c != '|' { return false; }

        cur_group_state.next_alternative();
        cur_branch_reset_state.next_alternative();
        return true;
    }

    is_anchor: (inout this, c: char) -> bool = {
        if c == '^' {
            cur_group_state.add(create_matcher("line_start_matcher_logic", "true"));
            return true;
        }
        else if c == '$' {
            cur_group_state.add(create_matcher("line_end_matcher_logic", "true, true"));
            return true;
        }

        return false;
    }

    is_any: (inout this, c: char) -> bool = {
        if c != '.' { return false; }

        cur_group_state.add(create_matcher("any_matcher_logic", ""));
        return true;

    }

    is_class: (inout this, c: char) -> bool = {
        if c != '[' { return false; }

        classes: std::vector<std::string> = ();

        c_cur: char = current();

        // First step: parse until the end bracket and push single chars, ranges or groups on the class stack.
        negate:= false;
        first:= true;
        range:= false;
        while next_in_class(out c_cur) & (c_cur != ']' || first) {
            if c_cur == '^' {
                negate = true;
                continue; // Skip rest of the loop. Also the first update.
            }
            if c_cur == '[' && peek_in_class() == ':' {
                // We have a character class.
                _ = skip_n(2);  // Skip [:

                name: std::string = "";
                if !grab_until(":]", out name) { error("Could not find end of character class."); return false; }
                if supported_classes.end() == std::find(supported_classes.begin(), supported_classes.end(), name) {
                    error("Unsupported character class. Supported ones are: (join(supported_classes))$");
                    return false;
                }

                classes.push_back("[:(name)$:]");

                _ = skip(); // Skip ':' pointing to the ending ']'.
            }
            else if c_cur == '\\' {
                if next_no_skip(out c_cur)  && (c_cur != ']') {
                    if  ' ' == c_cur && cur_group_state.modifiers.perl_code_syntax && cur_group_state.modifiers.perl_code_syntax_in_classes {
                        classes.push_back(std::string(1, c_cur)); // TODO: UFCS error with char as argument.
                    }
                    else {
                        name := "";
                            if 'd' == c_cur { name = "short_digits"; }
                        else if 'D' == c_cur { name = "short_not_digits"; }
                        else if 'h' == c_cur { name = "short_hor_space"; }
                        else if 'H' == c_cur { name = "short_not_hor_space"; }
                        else if 's' == c_cur { name = "short_space"; }
                        else if 'S' == c_cur { name = "short_not_space"; }
                        else if 'v' == c_cur { name = "short_ver_space"; }
                        else if 'V' == c_cur { name = "short_not_ver_space"; }
                        else if 'w' == c_cur { name = "short_word"; }
                        else if 'W' == c_cur { name = "short_not_word"; }
                        else {
                            error("Unknown group escape.");
                            return false;
                        }
                        classes.push_back("[:(name)$:]");
                    }
                } else {
                    error("Escape without a following character.");
                    return false;
                }
            }
            else if c_cur == '-' {
                if first { // Literal if first entry.
                    classes.push_back("(c_cur)$");
                } else {
                    range = true;
                }
            }
            else {
                if range { // Modify last element to be a range.
                    classes.back() += "-(c_cur)$";
                    range = false;
                }
                else {
                    classes.push_back("(c_cur)$");
                }
            }

            first = false;
        }

        if c_cur != ']' {
            error("Error end of character class definition before terminating ']'.");
            return false;
        }

        if range { // If '-' is last entry treat it as a literal char.
            classes.push_back("-");
        }

        // Second step: Wrap the item on the class stack with corresponding class implementation.
        for classes do (inout cur) {
            if cur.starts_with("[:") {
                name := cur.substr(2, cur.size() - 4);
                cur = create_matcher("(name)$_class", "");
            }
            else if 1 != cur.size() {
                cur = create_matcher("range_class_entry", "'(cur[0])$', '(cur[2])$'");
            }
            else {
                cur = create_matcher("single_class_entry", "'(cur)$'");
            }
        }

        inner := join(classes);
        cur_group_state.add(create_matcher("class_matcher_logic", "(negate)$, (inner)$"));
        return true;
    }

    is_escape: (inout this, c: char) -> bool = {
        if c != '\\' { return false; }

        start := pos; // Keep start for group matchers.
        c_next := '\0';
        if !next(out c_next) { error("Escape without a following character."); return false; }

        add_group_matcher:= :(name: std::string) -> bool = {

            name_trim := trim_copy(name);
            group_id : int = 0;
            if string_to_int(name_trim, group_id) {
                if group_id < 0 {
                    group_id = cur_branch_reset_state.cur_group + group_id;

                    if group_id < 1 { // Negative and zero are no valid groups.
                        error("Relative group reference does not reference a valid group. (Would be (group_id)$.)");
                        return false;
                    }
                }

                if group_id >= cur_branch_reset_state.cur_group { error("Group reference is used before the group is declared."); return false; }
            }
            else {
                // Named group
                iter := named_groups.find(name_trim);
                if iter == named_groups.end() { error("Group names does not exist. (Name is: (name)$)"); return false; }

                group_id = iter*.second;
            }
            cur_group_state.add(create_matcher("group_ref_matcher_logic", "(group_id)$, \"\\(regex.substr(start$, pos&$* - start$ + 1))$\""));

            return true;
        };

        if '0' <= c_next <= '9' {
            group := grab_number();
            if group.ssize() >= 3 {
                // \000 syntax
                number := 0;
                if !string_to_int(group, number, 8) { error("Could not convert octal to int."); return false; }

                number_as_char : char = unsafe_narrow<char>(number);

                syntax: std::string = "\\(int_to_string(number_as_char as int, 8))$";
                char_matcher := create_matcher("char_matcher_logic", "'(number_as_char)$', '(safe_tolower(number_as_char))$', '(safe_toupper(number_as_char))$'");
                cur_group_state.add(create_matcher("special_syntax_wrapper", "\"(syntax)$\", (char_matcher)$"));
            }
            else {
                if !add_group_matcher(group) { return false; }
            }
        }
        else if std::string::npos != std::string("tnrfae^.[]$()*{}?+|").find(c_next) {
            if c_next == '$' {
                // TODO: Provide proper escape for cppfront capture
                cur_group_state.add(create_matcher("line_end_matcher_logic", "true, true"));
            }
            else {
                inner := create_matcher("char_matcher_logic", "'\\(c_next)$', '\\(c_next)$', '\\(c_next)$'");
                cur_group_state.add(create_matcher("special_syntax_wrapper", "\"\\\\(c_next)$\", (inner)$"));
            }
        }
        else if '\\' == c_next {
            inner := create_matcher("char_matcher_logic", "'\\\\', '\\\\', '\\\\'");
            cur_group_state.add(create_matcher("special_syntax_wrapper", "\"\\\\\\\\\", (inner)$"));
        }
        else if 'g' == c_next {
            if !next(out c_next) {error("Group escape without a following char."); return false; }

            group : std::string = "";
            if c_next == '{' {
                if !(next(out c_next) && grab_until('}', out group)) { error("No ending bracket."); return false; }
            }
            else {
                group = grab_number();
            }
            if !add_group_matcher(group) { return false; }
        }
        else if 'k' == c_next {
            if !next(out c_next) {error("Group escape without a following char."); return false; }

            term_char := '\0';
            if c_next == '{' { term_char = '}'; }
            else if c_next == '<' { term_char = '>'; }
            else if c_next == '\'' { term_char = '\''; }
            else {
                error("Group escape has wrong operator."); return false;
            }

            group : std::string = "";
            if !(next(out c_next) && grab_until(term_char, out group)) { error("No ending bracket."); return false; }
            if !add_group_matcher(group) { return false; }
        }
        else if 'K' == c_next {
            cur_group_state.add(create_matcher("global_group_reset", ""));
        }
        else if 'x' == c_next {
            if !next(out c_next) { error("x escape without number."); return false; }
            has_brackets := false;
            number_str: std::string = "";
            if '{' == c_next {
                // TODO: Currently does not work since the compiler handles \x also.
                // Bracketed
                has_brackets = true;
                _  = skip(); // Skip '{'
                if !grab_until('}', out number_str) { error("No ending bracket for \\x"); return false; }
            }
            else {
                // grab two chars

                if !grab_n(2, out number_str) { error("Missing hexadecimal digits after \\x."); return false; }
            }

            number := 0;
            if !string_to_int(number_str, number, 16) { error("Could not convert hexadecimal to int."); return false; }

            number_as_char : char = unsafe_narrow<char>(number);

            syntax: std::string = int_to_string(number_as_char as int, 16);
            if has_brackets {
                syntax = "{(syntax)$}";
            }
            syntax = "\\x(syntax)$";
            char_matcher := create_matcher("char_matcher_logic", "'(number_as_char)$', '(safe_tolower(number_as_char))$', '(safe_toupper(number_as_char))$'");
            cur_group_state.add(create_matcher("special_syntax_wrapper", "\"(syntax)$\", (char_matcher)$"));
        }
        else if 'o' == c_next {
            if !next(out c_next) { error("o escape without bracket."); return false; }
            number_str: std::string = "";
            if '{' == c_next {
                _  = skip(); // Skip '{'
                if !grab_until('}', out number_str) { error("No ending bracket for \\o"); return false; }
            }

            number := 0;
            if !string_to_int(number_str, number, 8) { error("Could not convert octal to int."); return false; }

            number_as_char : char = unsafe_narrow<char>(number);

            syntax: std::string = "\\o{(int_to_string(number_as_char as int, 8))$}";
            char_matcher := create_matcher("char_matcher_logic", "'(number_as_char)$', '(safe_tolower(number_as_char))$', '(safe_toupper(number_as_char))$'");
            cur_group_state.add(create_matcher("special_syntax_wrapper", "\"(syntax)$\", (char_matcher)$"));
        }
        else if 'A' == c_next { cur_group_state.add(create_matcher("named_string_start", "")); }
        else if 'b' == c_next { cur_group_state.add(create_matcher("word_boundary_matcher_logic", "false")); }
        else if 'B' == c_next { cur_group_state.add(create_matcher("word_boundary_matcher_logic", "true")); }
        else if 'd' == c_next { cur_group_state.add(create_matcher("named_class_digits", "")); }
        else if 'D' == c_next { cur_group_state.add(create_matcher("named_class_not_digits", "")); }
        else if 'h' == c_next { cur_group_state.add(create_matcher("named_class_hor_space", "")); }
        else if 'H' == c_next { cur_group_state.add(create_matcher("named_class_not_hor_space", "")); }
        else if 'N' == c_next { cur_group_state.add(create_matcher("named_class_no_new_line", "")); }
        else if 's' == c_next { cur_group_state.add(create_matcher("named_class_space", "")); }
        else if 'S' == c_next { cur_group_state.add(create_matcher("named_class_not_space", "")); }
        else if 'v' == c_next { cur_group_state.add(create_matcher("named_class_ver_space", "")); }
        else if 'V' == c_next { cur_group_state.add(create_matcher("named_class_not_ver_space", "")); }
        else if 'w' == c_next { cur_group_state.add(create_matcher("named_class_word", "")); }
        else if 'W' == c_next { cur_group_state.add(create_matcher("named_class_not_word", "")); }
        else if 'Z' == c_next { cur_group_state.add(create_matcher("named_string_end_or_before_new_line_at_end", "")); }
        else if 'z' == c_next { cur_group_state.add(create_matcher("named_string_end", "")); }
        else {
            error("Unknown escape.");
            return false;
        }

        return true;
    }

    is_group: (inout this, c: char) -> bool = {
        if c != '(' { return false; }

        has_id := cur_group_state.modifiers.group_captures_have_numbers;
        has_pattern := true;
        group_name : std::string = "";
        group_name_brackets := true;
        modifier_change: std::string = "::cpp2::regex::match_modifiers_no_change";

        modifiers_change_to : = cur_group_state.modifiers;

        c_next : char = '\0';
        // Skip the '('
        if !next(out c_next) { error("Group without closing bracket."); return false;}
        if c_next == '?' {
            // Special group
            if !next_no_skip(out c_next) { error("Missing character after group opening."); return false; }

            if c_next == '<' || c_next == '\'' {
                // named group
                end_char := c_next;
                if end_char == '<' {
                    end_char = '>';
                } else {
                    group_name_brackets = false;
                }
                has_id = true; // Force id for named groups.
                if !next(out c_next) /* skip '<' */ { error("Missing ending bracket for named group."); return false; }
                if !grab_until(end_char, out group_name) { error("Missing ending bracket for named group."); return false; }
                if !next(out c_next) { error("Group without closing bracket."); return false;}
            }
            else if c_next == '#' {
                // Comment
                comment_str : std::string = "";
                if !grab_until(")", out comment_str) { error("Group without closing bracket."); return false;}
                // Do not add comment. Has problems with ranges.

                return true;
            }
            else if c_next == '|' {
                // Branch reset group

                if !next(out c_next) /* skip '|' */ { error("Missing ending bracket for named group."); return false; }

                old_parser_state: _ = group_new_state();
                old_branch_state: _ = branch_reset_new_state();
                parse_until(')');
                inner:= create_matcher_from_state();
                branch_reset_restore_state(old_branch_state);
                group_restore_state(old_parser_state);

                start_matcher := create_matcher("branch_reset_matcher_logic", "");
                end_matcher := create_matcher("special_group_end_logic", "");

                v: std::vector<std::string> = (start_matcher, inner, end_matcher);
                cur_group_state.add(create_matcher_from_list(v));

                return true;
            }
            else if c_next == '=' || c_next == '!' {
                _ = skip(); // Skip '!'
                // Positive or negative lookahead
                return parse_lookahead("?(c_next)$", c_next == '=');
            }
            else {
                // Simple modifier
                has_id = false;
                change_str : std::string = "";
                if !grab_until_one_of("):", out change_str) { error("Missing ending bracket for group."); return false; }
                if !parser_group_modifiers(change_str, out modifier_change, modifiers_change_to) {
                     return false;
                }

                if ')' == current() {
                    has_pattern = false;
                }
                else {
                    if !next(out c_next) /* skip ':' */ { error("Missing ending bracket for group."); return false; }
                }
            }
        }
        else if c_next == '*' {
            // named pattern
            _ = skip(); // Skip *.
            name: std::string = "";
            if !grab_until(':', out name) { error("Missing colon for named pattern."); return false; }

            if name == "pla" || name == "positive_lookahead" {
                return parse_lookahead("*(name)$:", true);
            }
            else if name == "nla" || name == "negative_lookahead" {
                return parse_lookahead("*(name)$:", false);
            }
            else {
                error("Unknown named group pattern: '(name)$'"); return false;
            }
        }

        if has_pattern {
            // regular group

            group_number := -1;
            if has_id {
                group_number = cur_branch_reset_state.next();
            }

            old_state: _ = group_new_state();
            cur_group_state.modifiers = modifiers_change_to;
            parse_until(')');
            inner:= create_matcher_from_state();
            group_restore_state(old_state);

            start_matcher := create_matcher("group_matcher_start_logic", "(group_number)$, (modifier_change)$, \"(group_name)$\", (group_name_brackets)$");
            if 0 != group_name.size() {
                if !named_groups.contains(group_name) { // Redefinition of group name is not an error. The left most one is retained.
                    named_groups[group_name] = group_number;
                }
            }
            end_matcher := create_matcher("group_matcher_end_logic", "(group_number)$");

            v: std::vector<std::string> = (start_matcher, inner, end_matcher);
            cur_group_state.add(create_matcher_from_list(v));
        }
        else {
            // Only a modifier
            cur_group_state.modifiers = modifiers_change_to;
            cur_group_state.add(create_matcher("modifier_matcher_logic", "(modifier_change)$"));
        }

        return true;
    }

    is_handle_special: (inout this, c: char) -> bool = {
        if c != '\'' { return false; }

        cur_group_state.add(create_matcher("char_matcher_logic", "'\\(c)$', '\\(c)$', '\\(c)$'"));
        return true;
    }

    parse_until:(inout this, term: char) = {
        c: char = current();
        while c != '\n' next _ = next(out c) {
            if c == term { return; }

            if !has_error && is_alternative(c) { continue; }
            if !has_error && is_any(c) { continue; }
            if !has_error && is_class(c) { continue; }
            if !has_error && is_escape(c) { continue; }
            if !has_error && is_anchor(c) { continue; }
            if !has_error && is_group(c) { continue; }
            if !has_error && is_handle_special(c) { continue; }

            if has_error { return; }

            // No special char, push a character match
            cur_group_state.add(create_matcher("char_matcher_logic", "'(c)$', '(safe_tolower(c))$', '(safe_toupper(c))$'"));
        }
    }

    create_named_group_lookup: (this) -> std::string = {
        res: std::string = "get_named_group_index: (name) -> int = {\n";

        // Generate if selection.
        sep: std::string = "";
        for named_groups do (cur) {
            res += "(sep)$if name == \"(cur.first)$\" { return (cur.second)$; }";
            sep = "else ";
        }

        // Generate else branch or return if list is empty.
        if named_groups.empty() {
            res += "  _ = name;\n";
            res += "  return -1;\n";
        }
        else {
            res += "  else { return -1; }\n";
        }
        res += "}\n";
        return res;
    }

    parse:(inout this) -> std::string = {
        mod   := parser_expression_modifiers();
        parse_ctx: parse_context = (regex);
        if !parse_ctx.parse() {
            error(parse_ctx.error_text);
            return "Error";
        }

        source += "{\n";
        source += "  group_count: type == std::integral_constant<int, (parse_ctx.group_count)$>;  //TODO: Use static constexpr when alpha limitation of nested types declarations is lifted.\n";
        source += "  initial_flags: type == std::integral_constant<int, (mod)$>;  //TODO: Use static constexpr when alpha limitation of nested types declarations is lifted.\n";

        gen_ctx: generation_context = ();
        source += gen_ctx.run(parse_ctx.get_tokens());
        source += "  entry: (cur, inout ctx, modifiers) -> _ = {\n";
        source += "    ctx.set_group_start(0, cur);\n";
        source += "    r := (gen_ctx.get_entry_func())$(cur, ctx, modifiers, cpp2::regex::true_end_func());\n";
        source += "    if r.matched { ctx.set_group_end(0, r.pos); }\n";
        source += "    return r;\n";
        source += "  }\n";

        string := parse_ctx.get_tokens()*.to_string();
        source += "  to_string: () -> std::string = { return \"(string)$\"; }\n";
        source += create_named_group_lookup();
        source += "}\n";

        _ = parse_ctx;

        std::cout << source << std::endl;

        return source;
    }
}

generate_template: <Err> (regex: std::string_view, modifier: std::string_view, err: Err) -> std::string = {
    parser: regex_parser<Err> = (regex, modifier, err);
    r := parser.parse();
    _ = parser;
    return r;
}

}
}
