
//  Copyright (c) Herb Sutter
//  SPDX-License-Identifier: CC-BY-NC-ND-4.0

// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

cpp2: namespace = {

regex: namespace = {

view: <CharT> type == std::basic_string_view<CharT>;
bstring: <CharT> type == std::basic_string<CharT>;

match_group: @struct <Iter> type = {
    start: Iter = ();
    end: Iter = ();

    matched: bool = false;
}

match_return: @struct <Iter> type = {
    matched: bool = false;
    pos: Iter = ();
}

match_context: <CharT, Iter, max_groups: size_t> type =
{
    public groups: std::array<match_group<Iter>, max_groups> = ();

    set_group_start: (inout this, pos, start) = {
        groups[pos].start = start;
    }

    set_group_end: (inout this, pos, end) = {
        groups[pos].end = end;
        groups[pos].matched = true;
    }

    get_group: (inout this, pos) groups[pos]&;
}

matcher_list: <List...> type = {
    match: <Iter> (begin: Iter, cur: Iter, end: Iter, inout ctx) select<Iter, List...>(begin, cur, end, ctx);

    match_combine: <Iter, OtherList...> (begin: Iter, cur: Iter, end: Iter, inout ctx, _: matcher_list<OtherList...>)
        select<Iter, List..., OtherList...>(begin, cur, end, ctx);

    private select: <Iter, First, Other...> (begin: Iter, cur: Iter, end: Iter, inout ctx)
        First::match(begin, cur, end, ctx, matcher_list<Other...>());
    private select: <Iter> (begin: Iter, cur: Iter, end: Iter, inout ctx) match_return<Iter>(true, cur);
}

regular_expression: <CharT, groups: size_t, Matcher> type = {

    Iter: type == view<CharT>::const_iterator;
    context: type == match_context<CharT, Iter, groups>;

    search: (in this, str: view<CharT>, inout ctx: context) -> bool = {
        cur := str.begin();
        end := str.end();
        while cur != end next (cur++) {
            if Matcher::match(cur, cur, end, ctx).matched {
                return true;
            }
        }

        return false;
    }

    to_string: (in this) -> _ = Matcher::to_string();
}

alternative_matcher_logic: <CharT, List ...> type = {

    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) match_all<Iter, Other, List...>(begin, cur, end, ctx, Other());
    private match_all: <Iter, Tail, First, Other ...> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Tail) -> match_return<Iter> = {
        r := First::match(begin, cur, end, ctx, Tail());
        if r.matched {
            return r;
        } else {
            if constexpr 0 != sizeof...(Other) {
                return match_all<Iter, Tail, Other...>(begin, cur, end, ctx, Tail());
            } else {
                return match_return<Iter>(false, end);
            }
        }
    }
}

char_matcher_logic: <CharT, C: CharT> type =
{
    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) -> match_return<Iter> = {
        if cur != end && cur* == C {
            return Other::match(begin, cur + 1, end, ctx);
        } else {
            return match_return<Iter>(false, end);
        }
    }
}

group_matcher_start_logic: <CharT, group: int> type = {
    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) -> match_return<Iter> = {
        ctx.set_group_start(group, cur);
        return Other::match(begin, cur, end, ctx);
    }
}

group_matcher_end_logic: <CharT, group: int> type = {
    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) -> match_return<Iter> = {
        ctx.set_group_end(group, cur);
        return Other::match(begin, cur, end, ctx);
    }
}

list_matcher_logic: <CharT, List> type =
{
    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) -> match_return<Iter> = {
        return List::match_combine(begin, cur, end, ctx, Other());
    }
}

range_matcher_logic: <CharT, M, min_count: int, max_count: int> type = {


    match: <Iter, Other> (begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other)
        match_greedy(0, begin, cur, end, ctx, Other());

    private is_below_upper_bound: (count: int) -> bool = {
        if -1 == max_count { return true; }
        else { return count < max_count; }
    }

    private is_in_range: (count: int) -> bool = {
        if -1 != min_count && count < min_count { return false; }
        if -1 != max_count && count > max_count { return false; }
        return true;
    }
    private match_greedy: <Iter, Other> (count: int, begin: Iter, cur: Iter, end: Iter, inout ctx, _ : Other) -> match_return<Iter> = {
        r:= M::match(begin, cur, end, ctx, matcher_list<>());
        if  is_below_upper_bound(count) && r.matched && r.pos != cur {
            return match_greedy(count + 1, begin, r.pos, end, ctx, Other());
        }
        else {
            if is_in_range(count) {
                return Other::match(begin, cur, end, ctx);
            }
            else {
                return match_return<Iter>(false, end);
            }
        }
    }
}


regex_parser_state: @struct type = {
    cur_match_list: std::vector<std::string> = ();
    alternate_match_lists: std::vector<std::vector<std::string>> = ();

    start_new_list: (inout this) = {
        new_list: std::vector<std::string> = ();
        std::swap(new_list, cur_match_list);
        _ = alternate_match_lists.insert(alternate_match_lists.begin(), new_list);
    }

    swap: (inout this, inout t: regex_parser_state) = {
        std::swap(cur_match_list, t.cur_match_list);
        std::swap(alternate_match_lists, t.alternate_match_lists);
    }

    add: (inout this, matcher: _) = {
        cur_match_list.push_back(matcher);
    }

    wrap_last: (inout this, matcher) = {
        last: std::string = cur_match_list.back();
        cur_match_list.back() = matcher(last);
        _ = matcher;
        _ = last;
    }

    empty: (this) -> bool = cur_match_list.empty();
}


regex_parser: <Error_out> type = {

    regex: std::string_view;
    cur_state: regex_parser_state = ();
    pos: size_t = 0;

    named_groups: int = 1; // Global capture group.

    error_out: Error_out;

    operator=: (out this, r: std::string_view, e: Error_out) = {
        this.regex = r;
        this.error_out = e;
    }

    error:(inout this, message: std::string) = {
        error_out("Error during parsing of regex '(regex)$' at position '(pos)$': (message)$");
    }

    is_alternative: (inout this, c: char) -> bool = {
        if c != '|' { return false; }

        cur_state.start_new_list();
        return true;
    }

    is_range: (inout this, c: char) -> bool = {

        if c != '{' { return false; }
        if cur_state.empty() { error("'{' without previous element."); }

        end: size_t = regex.find("}", pos);
        if end == std::string::npos { error("Missing closing bracket."); }

        inner: std::string = trim_copy(regex.substr(pos + 1, end - pos - 1));
        if inner.empty() { error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'"); }

        min_count: std::string = "-1";
        max_count: std::string = "-1";

        sep: size_t = inner.find(",");
        if sep == std::string::npos {
            min_count = inner;
            max_count = inner;
        }
        else {
            inner_first: std::string = trim_copy(inner.substr(0, sep));
            inner_last: std::string = trim_copy(inner.substr(sep + 1));

            if (inner_first.empty() && inner_last.empty()) {
                error("Empty range specifier. Either '{n}', '{n,}', '{,m}' '{n,m}'");
            }

            if !inner_first.empty() {
                min_count = inner_first;
            }
            if !inner_last.empty() {
                max_count = inner_last;
            }
        }

        // TODO: Check 0 <=n <= m
        cur_state.wrap_last( :(inner) -> _ == "::cpp2::regex::range_matcher_logic<char, (inner)$, (min_count$)$, (max_count$)$>");
        pos = end;

        return true;
    }

    parse_until:(inout this, term: char) = {
        while pos != regex.size() next pos += 1 {
            c: char = regex[pos];

            if c == term { return; }

            if is_alternative(c) { continue; }
            // if is_any(c) { continue; }
            // if is_class(c) { continue; }
            // if is_escape(c) { continue; }
            // if is_anchor(c) { continue; }
            // if is_group(c) { continue; }
            // if is_handle_special(c) { continue; }
            if is_range(c) { continue; }
            // if is_special_range(c) { continue; }

            // No special char push a character match
            cur_state.add("::cpp2::regex::char_matcher_logic<char, '(c)$'>");
        }
    }

    private join: (list: std::vector<std::string>) -> std::string = {
        r: std::string = "";

        seperator: std::string = "";
        for list do (cur) {
            r += seperator + cur;
            seperator = ", ";
        }

        return r;
    }

    create_matcher_from_list: (inout this, list)
            "::cpp2::regex::list_matcher_logic<char, ::cpp2::regex::matcher_list<(join(list))$>>"

    create_matcher_from_state: (inout this) -> std::string = {
        if 0 == cur_state.alternate_match_lists.size() { return create_matcher_from_list(cur_state.cur_match_list); }

        matcher: std::string = "::cpp2::regex::alternative_matcher_logic<char, ";

        seperator: std::string = "";
        add := :(list) = {
            matcher&$* += seperator&$* + create_matcher_from_list(list);
            seperator&$* = ", ";
        };

        cur := cur_state.alternate_match_lists.rbegin();
        while cur != cur_state.alternate_match_lists.rend() next( cur++ ) {
            add(cur*);
        }
        if 0 != cur_state.cur_match_list.size() { add(cur_state.cur_match_list); }
        matcher += ">";

        return matcher;
    }

    parse:(inout this) -> std::string = {

        parse_until('\0');

        inner := create_matcher_from_state();
        inner = "::cpp2::regex::group_matcher_start_logic<char, 0>, (inner)$, ::cpp2::regex::group_matcher_end_logic<char, 0>";
        return "::cpp2::regex::regular_expression<char, (named_groups)$, ::cpp2::regex::matcher_list<(inner)$>>";
    }

}

generate_template: <Err> (regex: std::string_view, err: Err) -> std::string = {
    parser: regex_parser<Err> = (regex, err);
    r := parser.parse();
    _ = parser;
    return r;
}

}
}
